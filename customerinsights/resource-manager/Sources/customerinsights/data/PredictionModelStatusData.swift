// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
import Foundation
import azureSwiftRuntime
internal struct PredictionModelStatusData : PredictionModelStatusProtocol {
    public var tenantId: String?
    public var predictionName: String?
    public var predictionGuidId: String?
    public var status: PredictionModelLifeCycleEnum
    public var message: String?
    public var trainingSetCount: Int32?
    public var testSetCount: Int32?
    public var validationSetCount: Int32?
    public var trainingAccuracy: Int32?
    public var signalsUsed: Int32?
    public var modelVersion: String?

        enum CodingKeys: String, CodingKey {case tenantId = "tenantId"
        case predictionName = "predictionName"
        case predictionGuidId = "predictionGuidId"
        case status = "status"
        case message = "message"
        case trainingSetCount = "trainingSetCount"
        case testSetCount = "testSetCount"
        case validationSetCount = "validationSetCount"
        case trainingAccuracy = "trainingAccuracy"
        case signalsUsed = "signalsUsed"
        case modelVersion = "modelVersion"
        }

  public init(status: PredictionModelLifeCycleEnum)  {
    self.status = status
  }

  public init(from decoder: Decoder) throws {
    let container = try decoder.container(keyedBy: CodingKeys.self)
      if container.contains(.tenantId) {
        self.tenantId = try container.decode(String?.self, forKey: .tenantId)
    }
    if container.contains(.predictionName) {
        self.predictionName = try container.decode(String?.self, forKey: .predictionName)
    }
    if container.contains(.predictionGuidId) {
        self.predictionGuidId = try container.decode(String?.self, forKey: .predictionGuidId)
    }
    self.status = try container.decode(PredictionModelLifeCycleEnum.self, forKey: .status)
    if container.contains(.message) {
        self.message = try container.decode(String?.self, forKey: .message)
    }
    if container.contains(.trainingSetCount) {
        self.trainingSetCount = try container.decode(Int32?.self, forKey: .trainingSetCount)
    }
    if container.contains(.testSetCount) {
        self.testSetCount = try container.decode(Int32?.self, forKey: .testSetCount)
    }
    if container.contains(.validationSetCount) {
        self.validationSetCount = try container.decode(Int32?.self, forKey: .validationSetCount)
    }
    if container.contains(.trainingAccuracy) {
        self.trainingAccuracy = try container.decode(Int32?.self, forKey: .trainingAccuracy)
    }
    if container.contains(.signalsUsed) {
        self.signalsUsed = try container.decode(Int32?.self, forKey: .signalsUsed)
    }
    if container.contains(.modelVersion) {
        self.modelVersion = try container.decode(String?.self, forKey: .modelVersion)
    }
    if var pageDecoder = decoder as? PageDecoder  {
      if pageDecoder.isPagedData,
        let nextLinkName = pageDecoder.nextLinkName {
          pageDecoder.nextLink = try UnknownCodingKey.decodeStringForKey(decoder: decoder, keyForDecode: nextLinkName)
      }
    }
  }

  public func encode(to encoder: Encoder) throws {
    var container = encoder.container(keyedBy: CodingKeys.self)
    if self.tenantId != nil {try container.encode(self.tenantId, forKey: .tenantId)}
    if self.predictionName != nil {try container.encode(self.predictionName, forKey: .predictionName)}
    if self.predictionGuidId != nil {try container.encode(self.predictionGuidId, forKey: .predictionGuidId)}
    try container.encode(self.status, forKey: .status)
    if self.message != nil {try container.encode(self.message, forKey: .message)}
    if self.trainingSetCount != nil {try container.encode(self.trainingSetCount, forKey: .trainingSetCount)}
    if self.testSetCount != nil {try container.encode(self.testSetCount, forKey: .testSetCount)}
    if self.validationSetCount != nil {try container.encode(self.validationSetCount, forKey: .validationSetCount)}
    if self.trainingAccuracy != nil {try container.encode(self.trainingAccuracy, forKey: .trainingAccuracy)}
    if self.signalsUsed != nil {try container.encode(self.signalsUsed, forKey: .signalsUsed)}
    if self.modelVersion != nil {try container.encode(self.modelVersion, forKey: .modelVersion)}
  }
}

extension DataFactory {
  public static func createPredictionModelStatusProtocol(status: PredictionModelLifeCycleEnum) -> PredictionModelStatusProtocol {
    return PredictionModelStatusData(status: status)
  }
}
