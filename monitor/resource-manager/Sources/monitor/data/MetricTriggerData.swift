// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
import Foundation
import azureSwiftRuntime
internal struct MetricTriggerData : MetricTriggerProtocol {
    public var metricName: String
    public var metricResourceUri: String
    public var timeGrain: String
    public var statistic: MetricStatisticTypeEnum
    public var timeWindow: String
    public var timeAggregation: TimeAggregationTypeEnum
    public var _operator: ComparisonOperationTypeEnum
    public var threshold: Double

        enum CodingKeys: String, CodingKey {case metricName = "metricName"
        case metricResourceUri = "metricResourceUri"
        case timeGrain = "timeGrain"
        case statistic = "statistic"
        case timeWindow = "timeWindow"
        case timeAggregation = "timeAggregation"
        case _operator = "operator"
        case threshold = "threshold"
        }

  public init(metricName: String, metricResourceUri: String, timeGrain: String, statistic: MetricStatisticTypeEnum, timeWindow: String, timeAggregation: TimeAggregationTypeEnum, _operator: ComparisonOperationTypeEnum, threshold: Double)  {
    self.metricName = metricName
    self.metricResourceUri = metricResourceUri
    self.timeGrain = timeGrain
    self.statistic = statistic
    self.timeWindow = timeWindow
    self.timeAggregation = timeAggregation
    self._operator = _operator
    self.threshold = threshold
  }

  public init(from decoder: Decoder) throws {
    let container = try decoder.container(keyedBy: CodingKeys.self)
      self.metricName = try container.decode(String.self, forKey: .metricName)
    self.metricResourceUri = try container.decode(String.self, forKey: .metricResourceUri)
    self.timeGrain = try container.decode(String.self, forKey: .timeGrain)
    self.statistic = try container.decode(MetricStatisticTypeEnum.self, forKey: .statistic)
    self.timeWindow = try container.decode(String.self, forKey: .timeWindow)
    self.timeAggregation = try container.decode(TimeAggregationTypeEnum.self, forKey: .timeAggregation)
    self._operator = try container.decode(ComparisonOperationTypeEnum.self, forKey: ._operator)
    self.threshold = try container.decode(Double.self, forKey: .threshold)
    if var pageDecoder = decoder as? PageDecoder  {
      if pageDecoder.isPagedData,
        let nextLinkName = pageDecoder.nextLinkName {
          pageDecoder.nextLink = try UnknownCodingKey.decodeStringForKey(decoder: decoder, keyForDecode: nextLinkName)
      }
    }
  }

  public func encode(to encoder: Encoder) throws {
    var container = encoder.container(keyedBy: CodingKeys.self)
    try container.encode(self.metricName, forKey: .metricName)
    try container.encode(self.metricResourceUri, forKey: .metricResourceUri)
    try container.encode(self.timeGrain, forKey: .timeGrain)
    try container.encode(self.statistic, forKey: .statistic)
    try container.encode(self.timeWindow, forKey: .timeWindow)
    try container.encode(self.timeAggregation, forKey: .timeAggregation)
    try container.encode(self._operator, forKey: ._operator)
    try container.encode(self.threshold, forKey: .threshold)
  }
}

extension DataFactory {
  public static func createMetricTriggerProtocol(metricName: String, metricResourceUri: String, timeGrain: String, statistic: MetricStatisticTypeEnum, timeWindow: String, timeAggregation: TimeAggregationTypeEnum, _operator: ComparisonOperationTypeEnum, threshold: Double) -> MetricTriggerProtocol {
    return MetricTriggerData(metricName: metricName, metricResourceUri: metricResourceUri, timeGrain: timeGrain, statistic: statistic, timeWindow: timeWindow, timeAggregation: timeAggregation, _operator: _operator, threshold: threshold)
  }
}
