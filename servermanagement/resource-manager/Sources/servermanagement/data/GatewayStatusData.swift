// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
import Foundation
import azureSwiftRuntime
internal struct GatewayStatusData : GatewayStatusProtocol {
    public var availableMemoryMByte: Double?
    public var gatewayCpuUtilizationPercent: Double?
    public var totalCpuUtilizationPercent: Double?
    public var gatewayVersion: String?
    public var friendlyOsName: String?
    public var installedDate: Date?
    public var logicalProcessorCount: Int32?
    public var name: String?
    public var gatewayId: String?
    public var gatewayWorkingSetMByte: Double?
    public var statusUpdated: Date?
    public var groupPolicyError: String?
    public var allowGatewayGroupPolicyStatus: Bool?
    public var requireMfaGroupPolicyStatus: Bool?
    public var encryptionCertificateThumbprint: String?
    public var secondaryEncryptionCertificateThumbprint: String?
    public var encryptionJwk: EncryptionJwkResourceProtocol?
    public var secondaryEncryptionJwk: EncryptionJwkResourceProtocol?
    public var activeMessageCount: Int32?
    public var latestPublishedMsiVersion: String?
    public var publishedTimeUtc: Date?

        enum CodingKeys: String, CodingKey {case availableMemoryMByte = "availableMemoryMByte"
        case gatewayCpuUtilizationPercent = "gatewayCpuUtilizationPercent"
        case totalCpuUtilizationPercent = "totalCpuUtilizationPercent"
        case gatewayVersion = "gatewayVersion"
        case friendlyOsName = "friendlyOsName"
        case installedDate = "installedDate"
        case logicalProcessorCount = "logicalProcessorCount"
        case name = "name"
        case gatewayId = "gatewayId"
        case gatewayWorkingSetMByte = "gatewayWorkingSetMByte"
        case statusUpdated = "statusUpdated"
        case groupPolicyError = "groupPolicyError"
        case allowGatewayGroupPolicyStatus = "allowGatewayGroupPolicyStatus"
        case requireMfaGroupPolicyStatus = "requireMfaGroupPolicyStatus"
        case encryptionCertificateThumbprint = "encryptionCertificateThumbprint"
        case secondaryEncryptionCertificateThumbprint = "secondaryEncryptionCertificateThumbprint"
        case encryptionJwk = "encryptionJwk"
        case secondaryEncryptionJwk = "secondaryEncryptionJwk"
        case activeMessageCount = "activeMessageCount"
        case latestPublishedMsiVersion = "latestPublishedMsiVersion"
        case publishedTimeUtc = "publishedTimeUtc"
        }

  public init()  {
  }

  public init(from decoder: Decoder) throws {
    let container = try decoder.container(keyedBy: CodingKeys.self)
      if container.contains(.availableMemoryMByte) {
        self.availableMemoryMByte = try container.decode(Double?.self, forKey: .availableMemoryMByte)
    }
    if container.contains(.gatewayCpuUtilizationPercent) {
        self.gatewayCpuUtilizationPercent = try container.decode(Double?.self, forKey: .gatewayCpuUtilizationPercent)
    }
    if container.contains(.totalCpuUtilizationPercent) {
        self.totalCpuUtilizationPercent = try container.decode(Double?.self, forKey: .totalCpuUtilizationPercent)
    }
    if container.contains(.gatewayVersion) {
        self.gatewayVersion = try container.decode(String?.self, forKey: .gatewayVersion)
    }
    if container.contains(.friendlyOsName) {
        self.friendlyOsName = try container.decode(String?.self, forKey: .friendlyOsName)
    }
    if container.contains(.installedDate) {
        self.installedDate = DateConverter.fromString(dateStr: (try container.decode(String?.self, forKey: .installedDate)), format: .dateTime)
    }
    if container.contains(.logicalProcessorCount) {
        self.logicalProcessorCount = try container.decode(Int32?.self, forKey: .logicalProcessorCount)
    }
    if container.contains(.name) {
        self.name = try container.decode(String?.self, forKey: .name)
    }
    if container.contains(.gatewayId) {
        self.gatewayId = try container.decode(String?.self, forKey: .gatewayId)
    }
    if container.contains(.gatewayWorkingSetMByte) {
        self.gatewayWorkingSetMByte = try container.decode(Double?.self, forKey: .gatewayWorkingSetMByte)
    }
    if container.contains(.statusUpdated) {
        self.statusUpdated = DateConverter.fromString(dateStr: (try container.decode(String?.self, forKey: .statusUpdated)), format: .dateTime)
    }
    if container.contains(.groupPolicyError) {
        self.groupPolicyError = try container.decode(String?.self, forKey: .groupPolicyError)
    }
    if container.contains(.allowGatewayGroupPolicyStatus) {
        self.allowGatewayGroupPolicyStatus = try container.decode(Bool?.self, forKey: .allowGatewayGroupPolicyStatus)
    }
    if container.contains(.requireMfaGroupPolicyStatus) {
        self.requireMfaGroupPolicyStatus = try container.decode(Bool?.self, forKey: .requireMfaGroupPolicyStatus)
    }
    if container.contains(.encryptionCertificateThumbprint) {
        self.encryptionCertificateThumbprint = try container.decode(String?.self, forKey: .encryptionCertificateThumbprint)
    }
    if container.contains(.secondaryEncryptionCertificateThumbprint) {
        self.secondaryEncryptionCertificateThumbprint = try container.decode(String?.self, forKey: .secondaryEncryptionCertificateThumbprint)
    }
    if container.contains(.encryptionJwk) {
        self.encryptionJwk = try container.decode(EncryptionJwkResourceData?.self, forKey: .encryptionJwk)
    }
    if container.contains(.secondaryEncryptionJwk) {
        self.secondaryEncryptionJwk = try container.decode(EncryptionJwkResourceData?.self, forKey: .secondaryEncryptionJwk)
    }
    if container.contains(.activeMessageCount) {
        self.activeMessageCount = try container.decode(Int32?.self, forKey: .activeMessageCount)
    }
    if container.contains(.latestPublishedMsiVersion) {
        self.latestPublishedMsiVersion = try container.decode(String?.self, forKey: .latestPublishedMsiVersion)
    }
    if container.contains(.publishedTimeUtc) {
        self.publishedTimeUtc = DateConverter.fromString(dateStr: (try container.decode(String?.self, forKey: .publishedTimeUtc)), format: .dateTime)
    }
    if var pageDecoder = decoder as? PageDecoder  {
      if pageDecoder.isPagedData,
        let nextLinkName = pageDecoder.nextLinkName {
          pageDecoder.nextLink = try UnknownCodingKey.decodeStringForKey(decoder: decoder, keyForDecode: nextLinkName)
      }
    }
  }

  public func encode(to encoder: Encoder) throws {
    var container = encoder.container(keyedBy: CodingKeys.self)
    if self.availableMemoryMByte != nil {try container.encode(self.availableMemoryMByte, forKey: .availableMemoryMByte)}
    if self.gatewayCpuUtilizationPercent != nil {try container.encode(self.gatewayCpuUtilizationPercent, forKey: .gatewayCpuUtilizationPercent)}
    if self.totalCpuUtilizationPercent != nil {try container.encode(self.totalCpuUtilizationPercent, forKey: .totalCpuUtilizationPercent)}
    if self.gatewayVersion != nil {try container.encode(self.gatewayVersion, forKey: .gatewayVersion)}
    if self.friendlyOsName != nil {try container.encode(self.friendlyOsName, forKey: .friendlyOsName)}
    if self.installedDate != nil {
        try container.encode(DateConverter.toString(date: self.installedDate!, format: .dateTime), forKey: .installedDate)
    }
    if self.logicalProcessorCount != nil {try container.encode(self.logicalProcessorCount, forKey: .logicalProcessorCount)}
    if self.name != nil {try container.encode(self.name, forKey: .name)}
    if self.gatewayId != nil {try container.encode(self.gatewayId, forKey: .gatewayId)}
    if self.gatewayWorkingSetMByte != nil {try container.encode(self.gatewayWorkingSetMByte, forKey: .gatewayWorkingSetMByte)}
    if self.statusUpdated != nil {
        try container.encode(DateConverter.toString(date: self.statusUpdated!, format: .dateTime), forKey: .statusUpdated)
    }
    if self.groupPolicyError != nil {try container.encode(self.groupPolicyError, forKey: .groupPolicyError)}
    if self.allowGatewayGroupPolicyStatus != nil {try container.encode(self.allowGatewayGroupPolicyStatus, forKey: .allowGatewayGroupPolicyStatus)}
    if self.requireMfaGroupPolicyStatus != nil {try container.encode(self.requireMfaGroupPolicyStatus, forKey: .requireMfaGroupPolicyStatus)}
    if self.encryptionCertificateThumbprint != nil {try container.encode(self.encryptionCertificateThumbprint, forKey: .encryptionCertificateThumbprint)}
    if self.secondaryEncryptionCertificateThumbprint != nil {try container.encode(self.secondaryEncryptionCertificateThumbprint, forKey: .secondaryEncryptionCertificateThumbprint)}
    if self.encryptionJwk != nil {try container.encode(self.encryptionJwk as! EncryptionJwkResourceData?, forKey: .encryptionJwk)}
    if self.secondaryEncryptionJwk != nil {try container.encode(self.secondaryEncryptionJwk as! EncryptionJwkResourceData?, forKey: .secondaryEncryptionJwk)}
    if self.activeMessageCount != nil {try container.encode(self.activeMessageCount, forKey: .activeMessageCount)}
    if self.latestPublishedMsiVersion != nil {try container.encode(self.latestPublishedMsiVersion, forKey: .latestPublishedMsiVersion)}
    if self.publishedTimeUtc != nil {
        try container.encode(DateConverter.toString(date: self.publishedTimeUtc!, format: .dateTime), forKey: .publishedTimeUtc)
    }
  }
}

extension DataFactory {
  public static func createGatewayStatusProtocol() -> GatewayStatusProtocol {
    return GatewayStatusData()
  }
}
