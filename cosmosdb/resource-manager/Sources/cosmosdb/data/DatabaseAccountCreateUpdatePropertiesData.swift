// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
import Foundation
import azureSwiftRuntime
internal struct DatabaseAccountCreateUpdatePropertiesData : DatabaseAccountCreateUpdatePropertiesProtocol {
    public var consistencyPolicy: ConsistencyPolicyProtocol?
    public var locations: [LocationProtocol]
    public var databaseAccountOfferType: String
    public var ipRangeFilter: String?
    public var enableAutomaticFailover: Bool?
    public var capabilities: [CapabilityProtocol?]?

        enum CodingKeys: String, CodingKey {case consistencyPolicy = "consistencyPolicy"
        case locations = "locations"
        case databaseAccountOfferType = "databaseAccountOfferType"
        case ipRangeFilter = "ipRangeFilter"
        case enableAutomaticFailover = "enableAutomaticFailover"
        case capabilities = "capabilities"
        }

  public init(locations: [LocationProtocol], databaseAccountOfferType: String)  {
    self.locations = locations
    self.databaseAccountOfferType = databaseAccountOfferType
  }

  public init(from decoder: Decoder) throws {
    let container = try decoder.container(keyedBy: CodingKeys.self)
      if container.contains(.consistencyPolicy) {
        self.consistencyPolicy = try container.decode(ConsistencyPolicyData?.self, forKey: .consistencyPolicy)
    }
    self.locations = try container.decode([LocationData].self, forKey: .locations)
    self.databaseAccountOfferType = try container.decode(String.self, forKey: .databaseAccountOfferType)
    if container.contains(.ipRangeFilter) {
        self.ipRangeFilter = try container.decode(String?.self, forKey: .ipRangeFilter)
    }
    if container.contains(.enableAutomaticFailover) {
        self.enableAutomaticFailover = try container.decode(Bool?.self, forKey: .enableAutomaticFailover)
    }
    if container.contains(.capabilities) {
        self.capabilities = try container.decode([CapabilityData?]?.self, forKey: .capabilities)
    }
    if var pageDecoder = decoder as? PageDecoder  {
      if pageDecoder.isPagedData,
        let nextLinkName = pageDecoder.nextLinkName {
          pageDecoder.nextLink = try UnknownCodingKey.decodeStringForKey(decoder: decoder, keyForDecode: nextLinkName)
      }
    }
  }

  public func encode(to encoder: Encoder) throws {
    var container = encoder.container(keyedBy: CodingKeys.self)
    if self.consistencyPolicy != nil {try container.encode(self.consistencyPolicy as! ConsistencyPolicyData?, forKey: .consistencyPolicy)}
    try container.encode(self.locations as! [LocationData], forKey: .locations)
    try container.encode(self.databaseAccountOfferType, forKey: .databaseAccountOfferType)
    if self.ipRangeFilter != nil {try container.encode(self.ipRangeFilter, forKey: .ipRangeFilter)}
    if self.enableAutomaticFailover != nil {try container.encode(self.enableAutomaticFailover, forKey: .enableAutomaticFailover)}
    if self.capabilities != nil {try container.encode(self.capabilities as! [CapabilityData?]?, forKey: .capabilities)}
  }
}

extension DataFactory {
  public static func createDatabaseAccountCreateUpdatePropertiesProtocol(locations: [LocationProtocol], databaseAccountOfferType: String) -> DatabaseAccountCreateUpdatePropertiesProtocol {
    return DatabaseAccountCreateUpdatePropertiesData(locations: locations, databaseAccountOfferType: databaseAccountOfferType)
  }
}
