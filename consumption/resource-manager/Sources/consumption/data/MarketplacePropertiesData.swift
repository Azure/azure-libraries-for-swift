// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
import Foundation
import azureSwiftRuntime
internal struct MarketplacePropertiesData : MarketplacePropertiesProtocol {
    public var billingPeriodId: String?
    public var usageStart: Date?
    public var usageEnd: Date?
    public var resourceRate: Decimal?
    public var offerName: String?
    public var resourceGroup: String?
    public var orderNumber: String?
    public var instanceName: String?
    public var instanceId: String?
    public var currency: String?
    public var consumedQuantity: Decimal?
    public var unitOfMeasure: String?
    public var pretaxCost: Decimal?
    public var isEstimated: Bool?
    public var meterId: String?
    public var subscriptionGuid: String?
    public var subscriptionName: String?
    public var accountName: String?
    public var departmentName: String?
    public var consumedService: String?
    public var costCenter: String?
    public var additionalProperties: String?
    public var publisherName: String?
    public var planName: String?

        enum CodingKeys: String, CodingKey {case billingPeriodId = "billingPeriodId"
        case usageStart = "usageStart"
        case usageEnd = "usageEnd"
        case resourceRate = "resourceRate"
        case offerName = "offerName"
        case resourceGroup = "resourceGroup"
        case orderNumber = "orderNumber"
        case instanceName = "instanceName"
        case instanceId = "instanceId"
        case currency = "currency"
        case consumedQuantity = "consumedQuantity"
        case unitOfMeasure = "unitOfMeasure"
        case pretaxCost = "pretaxCost"
        case isEstimated = "isEstimated"
        case meterId = "meterId"
        case subscriptionGuid = "subscriptionGuid"
        case subscriptionName = "subscriptionName"
        case accountName = "accountName"
        case departmentName = "departmentName"
        case consumedService = "consumedService"
        case costCenter = "costCenter"
        case additionalProperties = "additionalProperties"
        case publisherName = "publisherName"
        case planName = "planName"
        }

  public init()  {
  }

  public init(from decoder: Decoder) throws {
    let container = try decoder.container(keyedBy: CodingKeys.self)
      if container.contains(.billingPeriodId) {
        self.billingPeriodId = try container.decode(String?.self, forKey: .billingPeriodId)
    }
    if container.contains(.usageStart) {
        self.usageStart = DateConverter.fromString(dateStr: (try container.decode(String?.self, forKey: .usageStart)), format: .dateTime)
    }
    if container.contains(.usageEnd) {
        self.usageEnd = DateConverter.fromString(dateStr: (try container.decode(String?.self, forKey: .usageEnd)), format: .dateTime)
    }
    if container.contains(.resourceRate) {
        self.resourceRate = try container.decode(Decimal?.self, forKey: .resourceRate)
    }
    if container.contains(.offerName) {
        self.offerName = try container.decode(String?.self, forKey: .offerName)
    }
    if container.contains(.resourceGroup) {
        self.resourceGroup = try container.decode(String?.self, forKey: .resourceGroup)
    }
    if container.contains(.orderNumber) {
        self.orderNumber = try container.decode(String?.self, forKey: .orderNumber)
    }
    if container.contains(.instanceName) {
        self.instanceName = try container.decode(String?.self, forKey: .instanceName)
    }
    if container.contains(.instanceId) {
        self.instanceId = try container.decode(String?.self, forKey: .instanceId)
    }
    if container.contains(.currency) {
        self.currency = try container.decode(String?.self, forKey: .currency)
    }
    if container.contains(.consumedQuantity) {
        self.consumedQuantity = try container.decode(Decimal?.self, forKey: .consumedQuantity)
    }
    if container.contains(.unitOfMeasure) {
        self.unitOfMeasure = try container.decode(String?.self, forKey: .unitOfMeasure)
    }
    if container.contains(.pretaxCost) {
        self.pretaxCost = try container.decode(Decimal?.self, forKey: .pretaxCost)
    }
    if container.contains(.isEstimated) {
        self.isEstimated = try container.decode(Bool?.self, forKey: .isEstimated)
    }
    if container.contains(.meterId) {
        self.meterId = try container.decode(String?.self, forKey: .meterId)
    }
    if container.contains(.subscriptionGuid) {
        self.subscriptionGuid = try container.decode(String?.self, forKey: .subscriptionGuid)
    }
    if container.contains(.subscriptionName) {
        self.subscriptionName = try container.decode(String?.self, forKey: .subscriptionName)
    }
    if container.contains(.accountName) {
        self.accountName = try container.decode(String?.self, forKey: .accountName)
    }
    if container.contains(.departmentName) {
        self.departmentName = try container.decode(String?.self, forKey: .departmentName)
    }
    if container.contains(.consumedService) {
        self.consumedService = try container.decode(String?.self, forKey: .consumedService)
    }
    if container.contains(.costCenter) {
        self.costCenter = try container.decode(String?.self, forKey: .costCenter)
    }
    if container.contains(.additionalProperties) {
        self.additionalProperties = try container.decode(String?.self, forKey: .additionalProperties)
    }
    if container.contains(.publisherName) {
        self.publisherName = try container.decode(String?.self, forKey: .publisherName)
    }
    if container.contains(.planName) {
        self.planName = try container.decode(String?.self, forKey: .planName)
    }
    if var pageDecoder = decoder as? PageDecoder  {
      if pageDecoder.isPagedData,
        let nextLinkName = pageDecoder.nextLinkName {
          pageDecoder.nextLink = try UnknownCodingKey.decodeStringForKey(decoder: decoder, keyForDecode: nextLinkName)
      }
    }
  }

  public func encode(to encoder: Encoder) throws {
    var container = encoder.container(keyedBy: CodingKeys.self)
    if self.billingPeriodId != nil {try container.encode(self.billingPeriodId, forKey: .billingPeriodId)}
    if self.usageStart != nil {
        try container.encode(DateConverter.toString(date: self.usageStart!, format: .dateTime), forKey: .usageStart)
    }
    if self.usageEnd != nil {
        try container.encode(DateConverter.toString(date: self.usageEnd!, format: .dateTime), forKey: .usageEnd)
    }
    if self.resourceRate != nil {try container.encode(self.resourceRate, forKey: .resourceRate)}
    if self.offerName != nil {try container.encode(self.offerName, forKey: .offerName)}
    if self.resourceGroup != nil {try container.encode(self.resourceGroup, forKey: .resourceGroup)}
    if self.orderNumber != nil {try container.encode(self.orderNumber, forKey: .orderNumber)}
    if self.instanceName != nil {try container.encode(self.instanceName, forKey: .instanceName)}
    if self.instanceId != nil {try container.encode(self.instanceId, forKey: .instanceId)}
    if self.currency != nil {try container.encode(self.currency, forKey: .currency)}
    if self.consumedQuantity != nil {try container.encode(self.consumedQuantity, forKey: .consumedQuantity)}
    if self.unitOfMeasure != nil {try container.encode(self.unitOfMeasure, forKey: .unitOfMeasure)}
    if self.pretaxCost != nil {try container.encode(self.pretaxCost, forKey: .pretaxCost)}
    if self.isEstimated != nil {try container.encode(self.isEstimated, forKey: .isEstimated)}
    if self.meterId != nil {try container.encode(self.meterId, forKey: .meterId)}
    if self.subscriptionGuid != nil {try container.encode(self.subscriptionGuid, forKey: .subscriptionGuid)}
    if self.subscriptionName != nil {try container.encode(self.subscriptionName, forKey: .subscriptionName)}
    if self.accountName != nil {try container.encode(self.accountName, forKey: .accountName)}
    if self.departmentName != nil {try container.encode(self.departmentName, forKey: .departmentName)}
    if self.consumedService != nil {try container.encode(self.consumedService, forKey: .consumedService)}
    if self.costCenter != nil {try container.encode(self.costCenter, forKey: .costCenter)}
    if self.additionalProperties != nil {try container.encode(self.additionalProperties, forKey: .additionalProperties)}
    if self.publisherName != nil {try container.encode(self.publisherName, forKey: .publisherName)}
    if self.planName != nil {try container.encode(self.planName, forKey: .planName)}
  }
}

extension DataFactory {
  public static func createMarketplacePropertiesProtocol() -> MarketplacePropertiesProtocol {
    return MarketplacePropertiesData()
  }
}
