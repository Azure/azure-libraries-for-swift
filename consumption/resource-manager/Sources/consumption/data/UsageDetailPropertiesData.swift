// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
import Foundation
import azureSwiftRuntime
internal struct UsageDetailPropertiesData : UsageDetailPropertiesProtocol {
    public var billingPeriodId: String?
    public var invoiceId: String?
    public var usageStart: Date?
    public var usageEnd: Date?
    public var instanceName: String?
    public var instanceId: String?
    public var instanceLocation: String?
    public var currency: String?
    public var usageQuantity: Decimal?
    public var billableQuantity: Decimal?
    public var pretaxCost: Decimal?
    public var isEstimated: Bool?
    public var meterId: String?
    public var meterDetails: MeterDetailsProtocol?
    public var subscriptionGuid: String?
    public var subscriptionName: String?
    public var accountName: String?
    public var departmentName: String?
    public var product: String?
    public var consumedService: String?
    public var costCenter: String?
    public var additionalProperties: String?

        enum CodingKeys: String, CodingKey {case billingPeriodId = "billingPeriodId"
        case invoiceId = "invoiceId"
        case usageStart = "usageStart"
        case usageEnd = "usageEnd"
        case instanceName = "instanceName"
        case instanceId = "instanceId"
        case instanceLocation = "instanceLocation"
        case currency = "currency"
        case usageQuantity = "usageQuantity"
        case billableQuantity = "billableQuantity"
        case pretaxCost = "pretaxCost"
        case isEstimated = "isEstimated"
        case meterId = "meterId"
        case meterDetails = "meterDetails"
        case subscriptionGuid = "subscriptionGuid"
        case subscriptionName = "subscriptionName"
        case accountName = "accountName"
        case departmentName = "departmentName"
        case product = "product"
        case consumedService = "consumedService"
        case costCenter = "costCenter"
        case additionalProperties = "additionalProperties"
        }

  public init()  {
  }

  public init(from decoder: Decoder) throws {
    let container = try decoder.container(keyedBy: CodingKeys.self)
      if container.contains(.billingPeriodId) {
        self.billingPeriodId = try container.decode(String?.self, forKey: .billingPeriodId)
    }
    if container.contains(.invoiceId) {
        self.invoiceId = try container.decode(String?.self, forKey: .invoiceId)
    }
    if container.contains(.usageStart) {
        self.usageStart = DateConverter.fromString(dateStr: (try container.decode(String?.self, forKey: .usageStart)), format: .dateTime)
    }
    if container.contains(.usageEnd) {
        self.usageEnd = DateConverter.fromString(dateStr: (try container.decode(String?.self, forKey: .usageEnd)), format: .dateTime)
    }
    if container.contains(.instanceName) {
        self.instanceName = try container.decode(String?.self, forKey: .instanceName)
    }
    if container.contains(.instanceId) {
        self.instanceId = try container.decode(String?.self, forKey: .instanceId)
    }
    if container.contains(.instanceLocation) {
        self.instanceLocation = try container.decode(String?.self, forKey: .instanceLocation)
    }
    if container.contains(.currency) {
        self.currency = try container.decode(String?.self, forKey: .currency)
    }
    if container.contains(.usageQuantity) {
        self.usageQuantity = try container.decode(Decimal?.self, forKey: .usageQuantity)
    }
    if container.contains(.billableQuantity) {
        self.billableQuantity = try container.decode(Decimal?.self, forKey: .billableQuantity)
    }
    if container.contains(.pretaxCost) {
        self.pretaxCost = try container.decode(Decimal?.self, forKey: .pretaxCost)
    }
    if container.contains(.isEstimated) {
        self.isEstimated = try container.decode(Bool?.self, forKey: .isEstimated)
    }
    if container.contains(.meterId) {
        self.meterId = try container.decode(String?.self, forKey: .meterId)
    }
    if container.contains(.meterDetails) {
        self.meterDetails = try container.decode(MeterDetailsData?.self, forKey: .meterDetails)
    }
    if container.contains(.subscriptionGuid) {
        self.subscriptionGuid = try container.decode(String?.self, forKey: .subscriptionGuid)
    }
    if container.contains(.subscriptionName) {
        self.subscriptionName = try container.decode(String?.self, forKey: .subscriptionName)
    }
    if container.contains(.accountName) {
        self.accountName = try container.decode(String?.self, forKey: .accountName)
    }
    if container.contains(.departmentName) {
        self.departmentName = try container.decode(String?.self, forKey: .departmentName)
    }
    if container.contains(.product) {
        self.product = try container.decode(String?.self, forKey: .product)
    }
    if container.contains(.consumedService) {
        self.consumedService = try container.decode(String?.self, forKey: .consumedService)
    }
    if container.contains(.costCenter) {
        self.costCenter = try container.decode(String?.self, forKey: .costCenter)
    }
    if container.contains(.additionalProperties) {
        self.additionalProperties = try container.decode(String?.self, forKey: .additionalProperties)
    }
    if var pageDecoder = decoder as? PageDecoder  {
      if pageDecoder.isPagedData,
        let nextLinkName = pageDecoder.nextLinkName {
          pageDecoder.nextLink = try UnknownCodingKey.decodeStringForKey(decoder: decoder, keyForDecode: nextLinkName)
      }
    }
  }

  public func encode(to encoder: Encoder) throws {
    var container = encoder.container(keyedBy: CodingKeys.self)
    if self.billingPeriodId != nil {try container.encode(self.billingPeriodId, forKey: .billingPeriodId)}
    if self.invoiceId != nil {try container.encode(self.invoiceId, forKey: .invoiceId)}
    if self.usageStart != nil {
        try container.encode(DateConverter.toString(date: self.usageStart!, format: .dateTime), forKey: .usageStart)
    }
    if self.usageEnd != nil {
        try container.encode(DateConverter.toString(date: self.usageEnd!, format: .dateTime), forKey: .usageEnd)
    }
    if self.instanceName != nil {try container.encode(self.instanceName, forKey: .instanceName)}
    if self.instanceId != nil {try container.encode(self.instanceId, forKey: .instanceId)}
    if self.instanceLocation != nil {try container.encode(self.instanceLocation, forKey: .instanceLocation)}
    if self.currency != nil {try container.encode(self.currency, forKey: .currency)}
    if self.usageQuantity != nil {try container.encode(self.usageQuantity, forKey: .usageQuantity)}
    if self.billableQuantity != nil {try container.encode(self.billableQuantity, forKey: .billableQuantity)}
    if self.pretaxCost != nil {try container.encode(self.pretaxCost, forKey: .pretaxCost)}
    if self.isEstimated != nil {try container.encode(self.isEstimated, forKey: .isEstimated)}
    if self.meterId != nil {try container.encode(self.meterId, forKey: .meterId)}
    if self.meterDetails != nil {try container.encode(self.meterDetails as! MeterDetailsData?, forKey: .meterDetails)}
    if self.subscriptionGuid != nil {try container.encode(self.subscriptionGuid, forKey: .subscriptionGuid)}
    if self.subscriptionName != nil {try container.encode(self.subscriptionName, forKey: .subscriptionName)}
    if self.accountName != nil {try container.encode(self.accountName, forKey: .accountName)}
    if self.departmentName != nil {try container.encode(self.departmentName, forKey: .departmentName)}
    if self.product != nil {try container.encode(self.product, forKey: .product)}
    if self.consumedService != nil {try container.encode(self.consumedService, forKey: .consumedService)}
    if self.costCenter != nil {try container.encode(self.costCenter, forKey: .costCenter)}
    if self.additionalProperties != nil {try container.encode(self.additionalProperties, forKey: .additionalProperties)}
  }
}

extension DataFactory {
  public static func createUsageDetailPropertiesProtocol() -> UsageDetailPropertiesProtocol {
    return UsageDetailPropertiesData()
  }
}
