// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
import Foundation
import azureSwiftRuntime
internal struct PriceSheetPropertiesData : PriceSheetPropertiesProtocol {
    public var billingPeriodId: String?
    public var meterId: String?
    public var meterDetails: MeterDetailsProtocol?
    public var unitOfMeasure: String?
    public var includedQuantity: Decimal?
    public var partNumber: String?
    public var unitPrice: Decimal?
    public var currencyCode: String?

        enum CodingKeys: String, CodingKey {case billingPeriodId = "billingPeriodId"
        case meterId = "meterId"
        case meterDetails = "meterDetails"
        case unitOfMeasure = "unitOfMeasure"
        case includedQuantity = "includedQuantity"
        case partNumber = "partNumber"
        case unitPrice = "unitPrice"
        case currencyCode = "currencyCode"
        }

  public init()  {
  }

  public init(from decoder: Decoder) throws {
    let container = try decoder.container(keyedBy: CodingKeys.self)
      if container.contains(.billingPeriodId) {
        self.billingPeriodId = try container.decode(String?.self, forKey: .billingPeriodId)
    }
    if container.contains(.meterId) {
        self.meterId = try container.decode(String?.self, forKey: .meterId)
    }
    if container.contains(.meterDetails) {
        self.meterDetails = try container.decode(MeterDetailsData?.self, forKey: .meterDetails)
    }
    if container.contains(.unitOfMeasure) {
        self.unitOfMeasure = try container.decode(String?.self, forKey: .unitOfMeasure)
    }
    if container.contains(.includedQuantity) {
        self.includedQuantity = try container.decode(Decimal?.self, forKey: .includedQuantity)
    }
    if container.contains(.partNumber) {
        self.partNumber = try container.decode(String?.self, forKey: .partNumber)
    }
    if container.contains(.unitPrice) {
        self.unitPrice = try container.decode(Decimal?.self, forKey: .unitPrice)
    }
    if container.contains(.currencyCode) {
        self.currencyCode = try container.decode(String?.self, forKey: .currencyCode)
    }
    if var pageDecoder = decoder as? PageDecoder  {
      if pageDecoder.isPagedData,
        let nextLinkName = pageDecoder.nextLinkName {
          pageDecoder.nextLink = try UnknownCodingKey.decodeStringForKey(decoder: decoder, keyForDecode: nextLinkName)
      }
    }
  }

  public func encode(to encoder: Encoder) throws {
    var container = encoder.container(keyedBy: CodingKeys.self)
    if self.billingPeriodId != nil {try container.encode(self.billingPeriodId, forKey: .billingPeriodId)}
    if self.meterId != nil {try container.encode(self.meterId, forKey: .meterId)}
    if self.meterDetails != nil {try container.encode(self.meterDetails as! MeterDetailsData?, forKey: .meterDetails)}
    if self.unitOfMeasure != nil {try container.encode(self.unitOfMeasure, forKey: .unitOfMeasure)}
    if self.includedQuantity != nil {try container.encode(self.includedQuantity, forKey: .includedQuantity)}
    if self.partNumber != nil {try container.encode(self.partNumber, forKey: .partNumber)}
    if self.unitPrice != nil {try container.encode(self.unitPrice, forKey: .unitPrice)}
    if self.currencyCode != nil {try container.encode(self.currencyCode, forKey: .currencyCode)}
  }
}

extension DataFactory {
  public static func createPriceSheetPropertiesProtocol() -> PriceSheetPropertiesProtocol {
    return PriceSheetPropertiesData()
  }
}
