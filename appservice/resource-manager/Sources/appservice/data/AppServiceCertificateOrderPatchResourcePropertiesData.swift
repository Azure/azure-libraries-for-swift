// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
import Foundation
import azureSwiftRuntime
internal struct AppServiceCertificateOrderPatchResourcePropertiesData : AppServiceCertificateOrderPatchResourcePropertiesProtocol {
    public var certificates: [String:AppServiceCertificateProtocol?]?
    public var distinguishedName: String?
    public var domainVerificationToken: String?
    public var validityInYears: Int32?
    public var keySize: Int32?
    public var productType: CertificateProductTypeEnum?
    public var autoRenew: Bool?
    public var provisioningState: ProvisioningStateEnum?
    public var status: CertificateOrderStatusEnum?
    public var signedCertificate: CertificateDetailsProtocol?
    public var csr: String?
    public var intermediate: CertificateDetailsProtocol?
    public var root: CertificateDetailsProtocol?
    public var serialNumber: String?
    public var lastCertificateIssuanceTime: Date?
    public var expirationTime: Date?
    public var isPrivateKeyExternal: Bool?
    public var appServiceCertificateNotRenewableReasons: [String?]?
    public var nextAutoRenewalTimeStamp: Date?

        enum CodingKeys: String, CodingKey {case certificates = "certificates"
        case distinguishedName = "distinguishedName"
        case domainVerificationToken = "domainVerificationToken"
        case validityInYears = "validityInYears"
        case keySize = "keySize"
        case productType = "productType"
        case autoRenew = "autoRenew"
        case provisioningState = "provisioningState"
        case status = "status"
        case signedCertificate = "signedCertificate"
        case csr = "csr"
        case intermediate = "intermediate"
        case root = "root"
        case serialNumber = "serialNumber"
        case lastCertificateIssuanceTime = "lastCertificateIssuanceTime"
        case expirationTime = "expirationTime"
        case isPrivateKeyExternal = "isPrivateKeyExternal"
        case appServiceCertificateNotRenewableReasons = "appServiceCertificateNotRenewableReasons"
        case nextAutoRenewalTimeStamp = "nextAutoRenewalTimeStamp"
        }

  public init()  {
  }

  public init(from decoder: Decoder) throws {
    let container = try decoder.container(keyedBy: CodingKeys.self)
      if container.contains(.certificates) {
        self.certificates = try container.decode([String:AppServiceCertificateData?]?.self, forKey: .certificates)
    }
    if container.contains(.distinguishedName) {
        self.distinguishedName = try container.decode(String?.self, forKey: .distinguishedName)
    }
    if container.contains(.domainVerificationToken) {
        self.domainVerificationToken = try container.decode(String?.self, forKey: .domainVerificationToken)
    }
    if container.contains(.validityInYears) {
        self.validityInYears = try container.decode(Int32?.self, forKey: .validityInYears)
    }
    if container.contains(.keySize) {
        self.keySize = try container.decode(Int32?.self, forKey: .keySize)
    }
    if container.contains(.productType) {
        self.productType = try container.decode(CertificateProductTypeEnum?.self, forKey: .productType)
    }
    if container.contains(.autoRenew) {
        self.autoRenew = try container.decode(Bool?.self, forKey: .autoRenew)
    }
    if container.contains(.provisioningState) {
        self.provisioningState = try container.decode(ProvisioningStateEnum?.self, forKey: .provisioningState)
    }
    if container.contains(.status) {
        self.status = try container.decode(CertificateOrderStatusEnum?.self, forKey: .status)
    }
    if container.contains(.signedCertificate) {
        self.signedCertificate = try container.decode(CertificateDetailsData?.self, forKey: .signedCertificate)
    }
    if container.contains(.csr) {
        self.csr = try container.decode(String?.self, forKey: .csr)
    }
    if container.contains(.intermediate) {
        self.intermediate = try container.decode(CertificateDetailsData?.self, forKey: .intermediate)
    }
    if container.contains(.root) {
        self.root = try container.decode(CertificateDetailsData?.self, forKey: .root)
    }
    if container.contains(.serialNumber) {
        self.serialNumber = try container.decode(String?.self, forKey: .serialNumber)
    }
    if container.contains(.lastCertificateIssuanceTime) {
        self.lastCertificateIssuanceTime = DateConverter.fromString(dateStr: (try container.decode(String?.self, forKey: .lastCertificateIssuanceTime)), format: .dateTime)
    }
    if container.contains(.expirationTime) {
        self.expirationTime = DateConverter.fromString(dateStr: (try container.decode(String?.self, forKey: .expirationTime)), format: .dateTime)
    }
    if container.contains(.isPrivateKeyExternal) {
        self.isPrivateKeyExternal = try container.decode(Bool?.self, forKey: .isPrivateKeyExternal)
    }
    if container.contains(.appServiceCertificateNotRenewableReasons) {
        self.appServiceCertificateNotRenewableReasons = try container.decode([String?]?.self, forKey: .appServiceCertificateNotRenewableReasons)
    }
    if container.contains(.nextAutoRenewalTimeStamp) {
        self.nextAutoRenewalTimeStamp = DateConverter.fromString(dateStr: (try container.decode(String?.self, forKey: .nextAutoRenewalTimeStamp)), format: .dateTime)
    }
    if var pageDecoder = decoder as? PageDecoder  {
      if pageDecoder.isPagedData,
        let nextLinkName = pageDecoder.nextLinkName {
          pageDecoder.nextLink = try UnknownCodingKey.decodeStringForKey(decoder: decoder, keyForDecode: nextLinkName)
      }
    }
  }

  public func encode(to encoder: Encoder) throws {
    var container = encoder.container(keyedBy: CodingKeys.self)
    if self.certificates != nil {try container.encode(self.certificates, forKey: .certificates)}
    if self.distinguishedName != nil {try container.encode(self.distinguishedName, forKey: .distinguishedName)}
    if self.domainVerificationToken != nil {try container.encode(self.domainVerificationToken, forKey: .domainVerificationToken)}
    if self.validityInYears != nil {try container.encode(self.validityInYears, forKey: .validityInYears)}
    if self.keySize != nil {try container.encode(self.keySize, forKey: .keySize)}
    if self.productType != nil {try container.encode(self.productType, forKey: .productType)}
    if self.autoRenew != nil {try container.encode(self.autoRenew, forKey: .autoRenew)}
    if self.provisioningState != nil {try container.encode(self.provisioningState, forKey: .provisioningState)}
    if self.status != nil {try container.encode(self.status, forKey: .status)}
    if self.signedCertificate != nil {try container.encode(self.signedCertificate as! CertificateDetailsData?, forKey: .signedCertificate)}
    if self.csr != nil {try container.encode(self.csr, forKey: .csr)}
    if self.intermediate != nil {try container.encode(self.intermediate as! CertificateDetailsData?, forKey: .intermediate)}
    if self.root != nil {try container.encode(self.root as! CertificateDetailsData?, forKey: .root)}
    if self.serialNumber != nil {try container.encode(self.serialNumber, forKey: .serialNumber)}
    if self.lastCertificateIssuanceTime != nil {
        try container.encode(DateConverter.toString(date: self.lastCertificateIssuanceTime!, format: .dateTime), forKey: .lastCertificateIssuanceTime)
    }
    if self.expirationTime != nil {
        try container.encode(DateConverter.toString(date: self.expirationTime!, format: .dateTime), forKey: .expirationTime)
    }
    if self.isPrivateKeyExternal != nil {try container.encode(self.isPrivateKeyExternal, forKey: .isPrivateKeyExternal)}
    if self.appServiceCertificateNotRenewableReasons != nil {try container.encode(self.appServiceCertificateNotRenewableReasons as! [String?]?, forKey: .appServiceCertificateNotRenewableReasons)}
    if self.nextAutoRenewalTimeStamp != nil {
        try container.encode(DateConverter.toString(date: self.nextAutoRenewalTimeStamp!, format: .dateTime), forKey: .nextAutoRenewalTimeStamp)
    }
  }
}

extension DataFactory {
  public static func createAppServiceCertificateOrderPatchResourcePropertiesProtocol() -> AppServiceCertificateOrderPatchResourcePropertiesProtocol {
    return AppServiceCertificateOrderPatchResourcePropertiesData()
  }
}
