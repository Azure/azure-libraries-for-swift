// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
import Foundation
import azureSwiftRuntime
internal struct AppServiceEnvironmentData : AppServiceEnvironmentProtocol {
    public var name: String
    public var location: String
    public var provisioningState: ProvisioningStateEnum?
    public var status: HostingEnvironmentStatusEnum?
    public var vnetName: String?
    public var vnetResourceGroupName: String?
    public var vnetSubnetName: String?
    public var virtualNetwork: VirtualNetworkProfileProtocol
    public var internalLoadBalancingMode: InternalLoadBalancingModeEnum?
    public var multiSize: String?
    public var multiRoleCount: Int32?
    public var workerPools: [WorkerPoolProtocol]
    public var ipsslAddressCount: Int32?
    public var databaseEdition: String?
    public var databaseServiceObjective: String?
    public var upgradeDomains: Int32?
    public var subscriptionId: String?
    public var dnsSuffix: String?
    public var lastAction: String?
    public var lastActionResult: String?
    public var allowedMultiSizes: String?
    public var allowedWorkerSizes: String?
    public var maximumNumberOfMachines: Int32?
    public var vipMappings: [VirtualIPMappingProtocol?]?
    public var environmentCapacities: [StampCapacityProtocol?]?
    public var networkAccessControlList: [NetworkAccessControlEntryProtocol?]?
    public var environmentIsHealthy: Bool?
    public var environmentStatus: String?
    public var resourceGroup: String?
    public var frontEndScaleFactor: Int32?
    public var defaultFrontEndScaleFactor: Int32?
    public var apiManagementAccountId: String?
    public var suspended: Bool?
    public var dynamicCacheEnabled: Bool?
    public var clusterSettings: [NameValuePairProtocol?]?
    public var userWhitelistedIpRanges: [String]?

        enum CodingKeys: String, CodingKey {case name = "name"
        case location = "location"
        case provisioningState = "provisioningState"
        case status = "status"
        case vnetName = "vnetName"
        case vnetResourceGroupName = "vnetResourceGroupName"
        case vnetSubnetName = "vnetSubnetName"
        case virtualNetwork = "virtualNetwork"
        case internalLoadBalancingMode = "internalLoadBalancingMode"
        case multiSize = "multiSize"
        case multiRoleCount = "multiRoleCount"
        case workerPools = "workerPools"
        case ipsslAddressCount = "ipsslAddressCount"
        case databaseEdition = "databaseEdition"
        case databaseServiceObjective = "databaseServiceObjective"
        case upgradeDomains = "upgradeDomains"
        case subscriptionId = "subscriptionId"
        case dnsSuffix = "dnsSuffix"
        case lastAction = "lastAction"
        case lastActionResult = "lastActionResult"
        case allowedMultiSizes = "allowedMultiSizes"
        case allowedWorkerSizes = "allowedWorkerSizes"
        case maximumNumberOfMachines = "maximumNumberOfMachines"
        case vipMappings = "vipMappings"
        case environmentCapacities = "environmentCapacities"
        case networkAccessControlList = "networkAccessControlList"
        case environmentIsHealthy = "environmentIsHealthy"
        case environmentStatus = "environmentStatus"
        case resourceGroup = "resourceGroup"
        case frontEndScaleFactor = "frontEndScaleFactor"
        case defaultFrontEndScaleFactor = "defaultFrontEndScaleFactor"
        case apiManagementAccountId = "apiManagementAccountId"
        case suspended = "suspended"
        case dynamicCacheEnabled = "dynamicCacheEnabled"
        case clusterSettings = "clusterSettings"
        case userWhitelistedIpRanges = "userWhitelistedIpRanges"
        }

  public init(name: String, location: String, virtualNetwork: VirtualNetworkProfileProtocol, workerPools: [WorkerPoolProtocol])  {
    self.name = name
    self.location = location
    self.virtualNetwork = virtualNetwork
    self.workerPools = workerPools
  }

  public init(from decoder: Decoder) throws {
    let container = try decoder.container(keyedBy: CodingKeys.self)
      self.name = try container.decode(String.self, forKey: .name)
    self.location = try container.decode(String.self, forKey: .location)
    if container.contains(.provisioningState) {
        self.provisioningState = try container.decode(ProvisioningStateEnum?.self, forKey: .provisioningState)
    }
    if container.contains(.status) {
        self.status = try container.decode(HostingEnvironmentStatusEnum?.self, forKey: .status)
    }
    if container.contains(.vnetName) {
        self.vnetName = try container.decode(String?.self, forKey: .vnetName)
    }
    if container.contains(.vnetResourceGroupName) {
        self.vnetResourceGroupName = try container.decode(String?.self, forKey: .vnetResourceGroupName)
    }
    if container.contains(.vnetSubnetName) {
        self.vnetSubnetName = try container.decode(String?.self, forKey: .vnetSubnetName)
    }
    self.virtualNetwork = try container.decode(VirtualNetworkProfileData.self, forKey: .virtualNetwork)
    if container.contains(.internalLoadBalancingMode) {
        self.internalLoadBalancingMode = try container.decode(InternalLoadBalancingModeEnum?.self, forKey: .internalLoadBalancingMode)
    }
    if container.contains(.multiSize) {
        self.multiSize = try container.decode(String?.self, forKey: .multiSize)
    }
    if container.contains(.multiRoleCount) {
        self.multiRoleCount = try container.decode(Int32?.self, forKey: .multiRoleCount)
    }
    self.workerPools = try container.decode([WorkerPoolData].self, forKey: .workerPools)
    if container.contains(.ipsslAddressCount) {
        self.ipsslAddressCount = try container.decode(Int32?.self, forKey: .ipsslAddressCount)
    }
    if container.contains(.databaseEdition) {
        self.databaseEdition = try container.decode(String?.self, forKey: .databaseEdition)
    }
    if container.contains(.databaseServiceObjective) {
        self.databaseServiceObjective = try container.decode(String?.self, forKey: .databaseServiceObjective)
    }
    if container.contains(.upgradeDomains) {
        self.upgradeDomains = try container.decode(Int32?.self, forKey: .upgradeDomains)
    }
    if container.contains(.subscriptionId) {
        self.subscriptionId = try container.decode(String?.self, forKey: .subscriptionId)
    }
    if container.contains(.dnsSuffix) {
        self.dnsSuffix = try container.decode(String?.self, forKey: .dnsSuffix)
    }
    if container.contains(.lastAction) {
        self.lastAction = try container.decode(String?.self, forKey: .lastAction)
    }
    if container.contains(.lastActionResult) {
        self.lastActionResult = try container.decode(String?.self, forKey: .lastActionResult)
    }
    if container.contains(.allowedMultiSizes) {
        self.allowedMultiSizes = try container.decode(String?.self, forKey: .allowedMultiSizes)
    }
    if container.contains(.allowedWorkerSizes) {
        self.allowedWorkerSizes = try container.decode(String?.self, forKey: .allowedWorkerSizes)
    }
    if container.contains(.maximumNumberOfMachines) {
        self.maximumNumberOfMachines = try container.decode(Int32?.self, forKey: .maximumNumberOfMachines)
    }
    if container.contains(.vipMappings) {
        self.vipMappings = try container.decode([VirtualIPMappingData?]?.self, forKey: .vipMappings)
    }
    if container.contains(.environmentCapacities) {
        self.environmentCapacities = try container.decode([StampCapacityData?]?.self, forKey: .environmentCapacities)
    }
    if container.contains(.networkAccessControlList) {
        self.networkAccessControlList = try container.decode([NetworkAccessControlEntryData?]?.self, forKey: .networkAccessControlList)
    }
    if container.contains(.environmentIsHealthy) {
        self.environmentIsHealthy = try container.decode(Bool?.self, forKey: .environmentIsHealthy)
    }
    if container.contains(.environmentStatus) {
        self.environmentStatus = try container.decode(String?.self, forKey: .environmentStatus)
    }
    if container.contains(.resourceGroup) {
        self.resourceGroup = try container.decode(String?.self, forKey: .resourceGroup)
    }
    if container.contains(.frontEndScaleFactor) {
        self.frontEndScaleFactor = try container.decode(Int32?.self, forKey: .frontEndScaleFactor)
    }
    if container.contains(.defaultFrontEndScaleFactor) {
        self.defaultFrontEndScaleFactor = try container.decode(Int32?.self, forKey: .defaultFrontEndScaleFactor)
    }
    if container.contains(.apiManagementAccountId) {
        self.apiManagementAccountId = try container.decode(String?.self, forKey: .apiManagementAccountId)
    }
    if container.contains(.suspended) {
        self.suspended = try container.decode(Bool?.self, forKey: .suspended)
    }
    if container.contains(.dynamicCacheEnabled) {
        self.dynamicCacheEnabled = try container.decode(Bool?.self, forKey: .dynamicCacheEnabled)
    }
    if container.contains(.clusterSettings) {
        self.clusterSettings = try container.decode([NameValuePairData?]?.self, forKey: .clusterSettings)
    }
    if container.contains(.userWhitelistedIpRanges) {
        self.userWhitelistedIpRanges = try container.decode([String]?.self, forKey: .userWhitelistedIpRanges)
    }
    if var pageDecoder = decoder as? PageDecoder  {
      if pageDecoder.isPagedData,
        let nextLinkName = pageDecoder.nextLinkName {
          pageDecoder.nextLink = try UnknownCodingKey.decodeStringForKey(decoder: decoder, keyForDecode: nextLinkName)
      }
    }
  }

  public func encode(to encoder: Encoder) throws {
    var container = encoder.container(keyedBy: CodingKeys.self)
    try container.encode(self.name, forKey: .name)
    try container.encode(self.location, forKey: .location)
    if self.provisioningState != nil {try container.encode(self.provisioningState, forKey: .provisioningState)}
    if self.status != nil {try container.encode(self.status, forKey: .status)}
    if self.vnetName != nil {try container.encode(self.vnetName, forKey: .vnetName)}
    if self.vnetResourceGroupName != nil {try container.encode(self.vnetResourceGroupName, forKey: .vnetResourceGroupName)}
    if self.vnetSubnetName != nil {try container.encode(self.vnetSubnetName, forKey: .vnetSubnetName)}
    try container.encode(self.virtualNetwork as! VirtualNetworkProfileData, forKey: .virtualNetwork)
    if self.internalLoadBalancingMode != nil {try container.encode(self.internalLoadBalancingMode, forKey: .internalLoadBalancingMode)}
    if self.multiSize != nil {try container.encode(self.multiSize, forKey: .multiSize)}
    if self.multiRoleCount != nil {try container.encode(self.multiRoleCount, forKey: .multiRoleCount)}
    try container.encode(self.workerPools as! [WorkerPoolData], forKey: .workerPools)
    if self.ipsslAddressCount != nil {try container.encode(self.ipsslAddressCount, forKey: .ipsslAddressCount)}
    if self.databaseEdition != nil {try container.encode(self.databaseEdition, forKey: .databaseEdition)}
    if self.databaseServiceObjective != nil {try container.encode(self.databaseServiceObjective, forKey: .databaseServiceObjective)}
    if self.upgradeDomains != nil {try container.encode(self.upgradeDomains, forKey: .upgradeDomains)}
    if self.subscriptionId != nil {try container.encode(self.subscriptionId, forKey: .subscriptionId)}
    if self.dnsSuffix != nil {try container.encode(self.dnsSuffix, forKey: .dnsSuffix)}
    if self.lastAction != nil {try container.encode(self.lastAction, forKey: .lastAction)}
    if self.lastActionResult != nil {try container.encode(self.lastActionResult, forKey: .lastActionResult)}
    if self.allowedMultiSizes != nil {try container.encode(self.allowedMultiSizes, forKey: .allowedMultiSizes)}
    if self.allowedWorkerSizes != nil {try container.encode(self.allowedWorkerSizes, forKey: .allowedWorkerSizes)}
    if self.maximumNumberOfMachines != nil {try container.encode(self.maximumNumberOfMachines, forKey: .maximumNumberOfMachines)}
    if self.vipMappings != nil {try container.encode(self.vipMappings as! [VirtualIPMappingData?]?, forKey: .vipMappings)}
    if self.environmentCapacities != nil {try container.encode(self.environmentCapacities as! [StampCapacityData?]?, forKey: .environmentCapacities)}
    if self.networkAccessControlList != nil {try container.encode(self.networkAccessControlList as! [NetworkAccessControlEntryData?]?, forKey: .networkAccessControlList)}
    if self.environmentIsHealthy != nil {try container.encode(self.environmentIsHealthy, forKey: .environmentIsHealthy)}
    if self.environmentStatus != nil {try container.encode(self.environmentStatus, forKey: .environmentStatus)}
    if self.resourceGroup != nil {try container.encode(self.resourceGroup, forKey: .resourceGroup)}
    if self.frontEndScaleFactor != nil {try container.encode(self.frontEndScaleFactor, forKey: .frontEndScaleFactor)}
    if self.defaultFrontEndScaleFactor != nil {try container.encode(self.defaultFrontEndScaleFactor, forKey: .defaultFrontEndScaleFactor)}
    if self.apiManagementAccountId != nil {try container.encode(self.apiManagementAccountId, forKey: .apiManagementAccountId)}
    if self.suspended != nil {try container.encode(self.suspended, forKey: .suspended)}
    if self.dynamicCacheEnabled != nil {try container.encode(self.dynamicCacheEnabled, forKey: .dynamicCacheEnabled)}
    if self.clusterSettings != nil {try container.encode(self.clusterSettings as! [NameValuePairData?]?, forKey: .clusterSettings)}
    if self.userWhitelistedIpRanges != nil {try container.encode(self.userWhitelistedIpRanges as! [String]?, forKey: .userWhitelistedIpRanges)}
  }
}

extension DataFactory {
  public static func createAppServiceEnvironmentProtocol(name: String, location: String, virtualNetwork: VirtualNetworkProfileProtocol, workerPools: [WorkerPoolProtocol]) -> AppServiceEnvironmentProtocol {
    return AppServiceEnvironmentData(name: name, location: location, virtualNetwork: virtualNetwork, workerPools: workerPools)
  }
}
