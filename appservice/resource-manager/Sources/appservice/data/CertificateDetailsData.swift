// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
import Foundation
import azureSwiftRuntime
internal struct CertificateDetailsData : CertificateDetailsProtocol {
    public var version: Int32?
    public var serialNumber: String?
    public var thumbprint: String?
    public var subject: String?
    public var notBefore: Date?
    public var notAfter: Date?
    public var signatureAlgorithm: String?
    public var issuer: String?
    public var rawData: String?

        enum CodingKeys: String, CodingKey {case version = "version"
        case serialNumber = "serialNumber"
        case thumbprint = "thumbprint"
        case subject = "subject"
        case notBefore = "notBefore"
        case notAfter = "notAfter"
        case signatureAlgorithm = "signatureAlgorithm"
        case issuer = "issuer"
        case rawData = "rawData"
        }

  public init()  {
  }

  public init(from decoder: Decoder) throws {
    let container = try decoder.container(keyedBy: CodingKeys.self)
      if container.contains(.version) {
        self.version = try container.decode(Int32?.self, forKey: .version)
    }
    if container.contains(.serialNumber) {
        self.serialNumber = try container.decode(String?.self, forKey: .serialNumber)
    }
    if container.contains(.thumbprint) {
        self.thumbprint = try container.decode(String?.self, forKey: .thumbprint)
    }
    if container.contains(.subject) {
        self.subject = try container.decode(String?.self, forKey: .subject)
    }
    if container.contains(.notBefore) {
        self.notBefore = DateConverter.fromString(dateStr: (try container.decode(String?.self, forKey: .notBefore)), format: .dateTime)
    }
    if container.contains(.notAfter) {
        self.notAfter = DateConverter.fromString(dateStr: (try container.decode(String?.self, forKey: .notAfter)), format: .dateTime)
    }
    if container.contains(.signatureAlgorithm) {
        self.signatureAlgorithm = try container.decode(String?.self, forKey: .signatureAlgorithm)
    }
    if container.contains(.issuer) {
        self.issuer = try container.decode(String?.self, forKey: .issuer)
    }
    if container.contains(.rawData) {
        self.rawData = try container.decode(String?.self, forKey: .rawData)
    }
    if var pageDecoder = decoder as? PageDecoder  {
      if pageDecoder.isPagedData,
        let nextLinkName = pageDecoder.nextLinkName {
          pageDecoder.nextLink = try UnknownCodingKey.decodeStringForKey(decoder: decoder, keyForDecode: nextLinkName)
      }
    }
  }

  public func encode(to encoder: Encoder) throws {
    var container = encoder.container(keyedBy: CodingKeys.self)
    if self.version != nil {try container.encode(self.version, forKey: .version)}
    if self.serialNumber != nil {try container.encode(self.serialNumber, forKey: .serialNumber)}
    if self.thumbprint != nil {try container.encode(self.thumbprint, forKey: .thumbprint)}
    if self.subject != nil {try container.encode(self.subject, forKey: .subject)}
    if self.notBefore != nil {
        try container.encode(DateConverter.toString(date: self.notBefore!, format: .dateTime), forKey: .notBefore)
    }
    if self.notAfter != nil {
        try container.encode(DateConverter.toString(date: self.notAfter!, format: .dateTime), forKey: .notAfter)
    }
    if self.signatureAlgorithm != nil {try container.encode(self.signatureAlgorithm, forKey: .signatureAlgorithm)}
    if self.issuer != nil {try container.encode(self.issuer, forKey: .issuer)}
    if self.rawData != nil {try container.encode(self.rawData, forKey: .rawData)}
  }
}

extension DataFactory {
  public static func createCertificateDetailsProtocol() -> CertificateDetailsProtocol {
    return CertificateDetailsData()
  }
}
