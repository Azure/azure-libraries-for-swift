// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
import Foundation
import azureSwiftRuntime
internal struct ProcessInfoPropertiesData : ProcessInfoPropertiesProtocol {
    public var id: Int32?
    public var name: String?
    public var href: String?
    public var miniDump: String?
    public var isProfileRunning: Bool?
    public var isIisProfileRunning: Bool?
    public var iisProfileTimeoutInSeconds: Double?
    public var parent: String?
    public var children: [String]?
    public var threads: [ProcessThreadInfoProtocol?]?
    public var openFileHandles: [String]?
    public var modules: [ProcessModuleInfoProtocol?]?
    public var fileName: String?
    public var commandLine: String?
    public var userName: String?
    public var handleCount: Int32?
    public var moduleCount: Int32?
    public var threadCount: Int32?
    public var startTime: Date?
    public var totalProcessorTime: String?
    public var userProcessorTime: String?
    public var privilegedProcessorTime: String?
    public var workingSet64: Int64?
    public var peakWorkingSet64: Int64?
    public var privateMemorySize64: Int64?
    public var virtualMemorySize64: Int64?
    public var peakVirtualMemorySize64: Int64?
    public var pagedSystemMemorySize64: Int64?
    public var nonpagedSystemMemorySize64: Int64?
    public var pagedMemorySize64: Int64?
    public var peakPagedMemorySize64: Int64?
    public var timeStamp: Date?
    public var environmentVariables: [String:String]?
    public var isScmSite: Bool?
    public var isWebJob: Bool?
    public var description: String?

        enum CodingKeys: String, CodingKey {case id = "id"
        case name = "name"
        case href = "href"
        case miniDump = "miniDump"
        case isProfileRunning = "isProfileRunning"
        case isIisProfileRunning = "isIisProfileRunning"
        case iisProfileTimeoutInSeconds = "iisProfileTimeoutInSeconds"
        case parent = "parent"
        case children = "children"
        case threads = "threads"
        case openFileHandles = "openFileHandles"
        case modules = "modules"
        case fileName = "fileName"
        case commandLine = "commandLine"
        case userName = "userName"
        case handleCount = "handleCount"
        case moduleCount = "moduleCount"
        case threadCount = "threadCount"
        case startTime = "startTime"
        case totalProcessorTime = "totalProcessorTime"
        case userProcessorTime = "userProcessorTime"
        case privilegedProcessorTime = "privilegedProcessorTime"
        case workingSet64 = "workingSet64"
        case peakWorkingSet64 = "peakWorkingSet64"
        case privateMemorySize64 = "privateMemorySize64"
        case virtualMemorySize64 = "virtualMemorySize64"
        case peakVirtualMemorySize64 = "peakVirtualMemorySize64"
        case pagedSystemMemorySize64 = "pagedSystemMemorySize64"
        case nonpagedSystemMemorySize64 = "nonpagedSystemMemorySize64"
        case pagedMemorySize64 = "pagedMemorySize64"
        case peakPagedMemorySize64 = "peakPagedMemorySize64"
        case timeStamp = "timeStamp"
        case environmentVariables = "environmentVariables"
        case isScmSite = "isScmSite"
        case isWebJob = "isWebJob"
        case description = "description"
        }

  public init()  {
  }

  public init(from decoder: Decoder) throws {
    let container = try decoder.container(keyedBy: CodingKeys.self)
      if container.contains(.id) {
        self.id = try container.decode(Int32?.self, forKey: .id)
    }
    if container.contains(.name) {
        self.name = try container.decode(String?.self, forKey: .name)
    }
    if container.contains(.href) {
        self.href = try container.decode(String?.self, forKey: .href)
    }
    if container.contains(.miniDump) {
        self.miniDump = try container.decode(String?.self, forKey: .miniDump)
    }
    if container.contains(.isProfileRunning) {
        self.isProfileRunning = try container.decode(Bool?.self, forKey: .isProfileRunning)
    }
    if container.contains(.isIisProfileRunning) {
        self.isIisProfileRunning = try container.decode(Bool?.self, forKey: .isIisProfileRunning)
    }
    if container.contains(.iisProfileTimeoutInSeconds) {
        self.iisProfileTimeoutInSeconds = try container.decode(Double?.self, forKey: .iisProfileTimeoutInSeconds)
    }
    if container.contains(.parent) {
        self.parent = try container.decode(String?.self, forKey: .parent)
    }
    if container.contains(.children) {
        self.children = try container.decode([String]?.self, forKey: .children)
    }
    if container.contains(.threads) {
        self.threads = try container.decode([ProcessThreadInfoData?]?.self, forKey: .threads)
    }
    if container.contains(.openFileHandles) {
        self.openFileHandles = try container.decode([String]?.self, forKey: .openFileHandles)
    }
    if container.contains(.modules) {
        self.modules = try container.decode([ProcessModuleInfoData?]?.self, forKey: .modules)
    }
    if container.contains(.fileName) {
        self.fileName = try container.decode(String?.self, forKey: .fileName)
    }
    if container.contains(.commandLine) {
        self.commandLine = try container.decode(String?.self, forKey: .commandLine)
    }
    if container.contains(.userName) {
        self.userName = try container.decode(String?.self, forKey: .userName)
    }
    if container.contains(.handleCount) {
        self.handleCount = try container.decode(Int32?.self, forKey: .handleCount)
    }
    if container.contains(.moduleCount) {
        self.moduleCount = try container.decode(Int32?.self, forKey: .moduleCount)
    }
    if container.contains(.threadCount) {
        self.threadCount = try container.decode(Int32?.self, forKey: .threadCount)
    }
    if container.contains(.startTime) {
        self.startTime = DateConverter.fromString(dateStr: (try container.decode(String?.self, forKey: .startTime)), format: .dateTime)
    }
    if container.contains(.totalProcessorTime) {
        self.totalProcessorTime = try container.decode(String?.self, forKey: .totalProcessorTime)
    }
    if container.contains(.userProcessorTime) {
        self.userProcessorTime = try container.decode(String?.self, forKey: .userProcessorTime)
    }
    if container.contains(.privilegedProcessorTime) {
        self.privilegedProcessorTime = try container.decode(String?.self, forKey: .privilegedProcessorTime)
    }
    if container.contains(.workingSet64) {
        self.workingSet64 = try container.decode(Int64?.self, forKey: .workingSet64)
    }
    if container.contains(.peakWorkingSet64) {
        self.peakWorkingSet64 = try container.decode(Int64?.self, forKey: .peakWorkingSet64)
    }
    if container.contains(.privateMemorySize64) {
        self.privateMemorySize64 = try container.decode(Int64?.self, forKey: .privateMemorySize64)
    }
    if container.contains(.virtualMemorySize64) {
        self.virtualMemorySize64 = try container.decode(Int64?.self, forKey: .virtualMemorySize64)
    }
    if container.contains(.peakVirtualMemorySize64) {
        self.peakVirtualMemorySize64 = try container.decode(Int64?.self, forKey: .peakVirtualMemorySize64)
    }
    if container.contains(.pagedSystemMemorySize64) {
        self.pagedSystemMemorySize64 = try container.decode(Int64?.self, forKey: .pagedSystemMemorySize64)
    }
    if container.contains(.nonpagedSystemMemorySize64) {
        self.nonpagedSystemMemorySize64 = try container.decode(Int64?.self, forKey: .nonpagedSystemMemorySize64)
    }
    if container.contains(.pagedMemorySize64) {
        self.pagedMemorySize64 = try container.decode(Int64?.self, forKey: .pagedMemorySize64)
    }
    if container.contains(.peakPagedMemorySize64) {
        self.peakPagedMemorySize64 = try container.decode(Int64?.self, forKey: .peakPagedMemorySize64)
    }
    if container.contains(.timeStamp) {
        self.timeStamp = DateConverter.fromString(dateStr: (try container.decode(String?.self, forKey: .timeStamp)), format: .dateTime)
    }
    if container.contains(.environmentVariables) {
        self.environmentVariables = try container.decode([String:String]?.self, forKey: .environmentVariables)
    }
    if container.contains(.isScmSite) {
        self.isScmSite = try container.decode(Bool?.self, forKey: .isScmSite)
    }
    if container.contains(.isWebJob) {
        self.isWebJob = try container.decode(Bool?.self, forKey: .isWebJob)
    }
    if container.contains(.description) {
        self.description = try container.decode(String?.self, forKey: .description)
    }
    if var pageDecoder = decoder as? PageDecoder  {
      if pageDecoder.isPagedData,
        let nextLinkName = pageDecoder.nextLinkName {
          pageDecoder.nextLink = try UnknownCodingKey.decodeStringForKey(decoder: decoder, keyForDecode: nextLinkName)
      }
    }
  }

  public func encode(to encoder: Encoder) throws {
    var container = encoder.container(keyedBy: CodingKeys.self)
    if self.id != nil {try container.encode(self.id, forKey: .id)}
    if self.name != nil {try container.encode(self.name, forKey: .name)}
    if self.href != nil {try container.encode(self.href, forKey: .href)}
    if self.miniDump != nil {try container.encode(self.miniDump, forKey: .miniDump)}
    if self.isProfileRunning != nil {try container.encode(self.isProfileRunning, forKey: .isProfileRunning)}
    if self.isIisProfileRunning != nil {try container.encode(self.isIisProfileRunning, forKey: .isIisProfileRunning)}
    if self.iisProfileTimeoutInSeconds != nil {try container.encode(self.iisProfileTimeoutInSeconds, forKey: .iisProfileTimeoutInSeconds)}
    if self.parent != nil {try container.encode(self.parent, forKey: .parent)}
    if self.children != nil {try container.encode(self.children as! [String]?, forKey: .children)}
    if self.threads != nil {try container.encode(self.threads as! [ProcessThreadInfoData?]?, forKey: .threads)}
    if self.openFileHandles != nil {try container.encode(self.openFileHandles as! [String]?, forKey: .openFileHandles)}
    if self.modules != nil {try container.encode(self.modules as! [ProcessModuleInfoData?]?, forKey: .modules)}
    if self.fileName != nil {try container.encode(self.fileName, forKey: .fileName)}
    if self.commandLine != nil {try container.encode(self.commandLine, forKey: .commandLine)}
    if self.userName != nil {try container.encode(self.userName, forKey: .userName)}
    if self.handleCount != nil {try container.encode(self.handleCount, forKey: .handleCount)}
    if self.moduleCount != nil {try container.encode(self.moduleCount, forKey: .moduleCount)}
    if self.threadCount != nil {try container.encode(self.threadCount, forKey: .threadCount)}
    if self.startTime != nil {
        try container.encode(DateConverter.toString(date: self.startTime!, format: .dateTime), forKey: .startTime)
    }
    if self.totalProcessorTime != nil {try container.encode(self.totalProcessorTime, forKey: .totalProcessorTime)}
    if self.userProcessorTime != nil {try container.encode(self.userProcessorTime, forKey: .userProcessorTime)}
    if self.privilegedProcessorTime != nil {try container.encode(self.privilegedProcessorTime, forKey: .privilegedProcessorTime)}
    if self.workingSet64 != nil {try container.encode(self.workingSet64, forKey: .workingSet64)}
    if self.peakWorkingSet64 != nil {try container.encode(self.peakWorkingSet64, forKey: .peakWorkingSet64)}
    if self.privateMemorySize64 != nil {try container.encode(self.privateMemorySize64, forKey: .privateMemorySize64)}
    if self.virtualMemorySize64 != nil {try container.encode(self.virtualMemorySize64, forKey: .virtualMemorySize64)}
    if self.peakVirtualMemorySize64 != nil {try container.encode(self.peakVirtualMemorySize64, forKey: .peakVirtualMemorySize64)}
    if self.pagedSystemMemorySize64 != nil {try container.encode(self.pagedSystemMemorySize64, forKey: .pagedSystemMemorySize64)}
    if self.nonpagedSystemMemorySize64 != nil {try container.encode(self.nonpagedSystemMemorySize64, forKey: .nonpagedSystemMemorySize64)}
    if self.pagedMemorySize64 != nil {try container.encode(self.pagedMemorySize64, forKey: .pagedMemorySize64)}
    if self.peakPagedMemorySize64 != nil {try container.encode(self.peakPagedMemorySize64, forKey: .peakPagedMemorySize64)}
    if self.timeStamp != nil {
        try container.encode(DateConverter.toString(date: self.timeStamp!, format: .dateTime), forKey: .timeStamp)
    }
    if self.environmentVariables != nil {try container.encode(self.environmentVariables, forKey: .environmentVariables)}
    if self.isScmSite != nil {try container.encode(self.isScmSite, forKey: .isScmSite)}
    if self.isWebJob != nil {try container.encode(self.isWebJob, forKey: .isWebJob)}
    if self.description != nil {try container.encode(self.description, forKey: .description)}
  }
}

extension DataFactory {
  public static func createProcessInfoPropertiesProtocol() -> ProcessInfoPropertiesProtocol {
    return ProcessInfoPropertiesData()
  }
}
