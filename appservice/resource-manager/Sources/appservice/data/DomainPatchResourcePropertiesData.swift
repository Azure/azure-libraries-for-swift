// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
import Foundation
import azureSwiftRuntime
internal struct DomainPatchResourcePropertiesData : DomainPatchResourcePropertiesProtocol {
    public var contactAdmin: ContactProtocol?
    public var contactBilling: ContactProtocol?
    public var contactRegistrant: ContactProtocol?
    public var contactTech: ContactProtocol?
    public var registrationStatus: DomainStatusEnum?
    public var provisioningState: ProvisioningStateEnum?
    public var nameServers: [String]?
    public var privacy: Bool?
    public var createdTime: Date?
    public var expirationTime: Date?
    public var lastRenewedTime: Date?
    public var autoRenew: Bool?
    public var readyForDnsRecordManagement: Bool?
    public var managedHostNames: [HostNameProtocol?]?
    public var consent: DomainPurchaseConsentProtocol?
    public var domainNotRenewableReasons: [String?]?
    public var dnsType: DnsTypeEnum?
    public var dnsZoneId: String?
    public var targetDnsType: DnsTypeEnum?
    public var authCode: String?

        enum CodingKeys: String, CodingKey {case contactAdmin = "contactAdmin"
        case contactBilling = "contactBilling"
        case contactRegistrant = "contactRegistrant"
        case contactTech = "contactTech"
        case registrationStatus = "registrationStatus"
        case provisioningState = "provisioningState"
        case nameServers = "nameServers"
        case privacy = "privacy"
        case createdTime = "createdTime"
        case expirationTime = "expirationTime"
        case lastRenewedTime = "lastRenewedTime"
        case autoRenew = "autoRenew"
        case readyForDnsRecordManagement = "readyForDnsRecordManagement"
        case managedHostNames = "managedHostNames"
        case consent = "consent"
        case domainNotRenewableReasons = "domainNotRenewableReasons"
        case dnsType = "dnsType"
        case dnsZoneId = "dnsZoneId"
        case targetDnsType = "targetDnsType"
        case authCode = "authCode"
        }

  public init()  {
  }

  public init(from decoder: Decoder) throws {
    let container = try decoder.container(keyedBy: CodingKeys.self)
      if container.contains(.contactAdmin) {
        self.contactAdmin = try container.decode(ContactData?.self, forKey: .contactAdmin)
    }
    if container.contains(.contactBilling) {
        self.contactBilling = try container.decode(ContactData?.self, forKey: .contactBilling)
    }
    if container.contains(.contactRegistrant) {
        self.contactRegistrant = try container.decode(ContactData?.self, forKey: .contactRegistrant)
    }
    if container.contains(.contactTech) {
        self.contactTech = try container.decode(ContactData?.self, forKey: .contactTech)
    }
    if container.contains(.registrationStatus) {
        self.registrationStatus = try container.decode(DomainStatusEnum?.self, forKey: .registrationStatus)
    }
    if container.contains(.provisioningState) {
        self.provisioningState = try container.decode(ProvisioningStateEnum?.self, forKey: .provisioningState)
    }
    if container.contains(.nameServers) {
        self.nameServers = try container.decode([String]?.self, forKey: .nameServers)
    }
    if container.contains(.privacy) {
        self.privacy = try container.decode(Bool?.self, forKey: .privacy)
    }
    if container.contains(.createdTime) {
        self.createdTime = DateConverter.fromString(dateStr: (try container.decode(String?.self, forKey: .createdTime)), format: .dateTime)
    }
    if container.contains(.expirationTime) {
        self.expirationTime = DateConverter.fromString(dateStr: (try container.decode(String?.self, forKey: .expirationTime)), format: .dateTime)
    }
    if container.contains(.lastRenewedTime) {
        self.lastRenewedTime = DateConverter.fromString(dateStr: (try container.decode(String?.self, forKey: .lastRenewedTime)), format: .dateTime)
    }
    if container.contains(.autoRenew) {
        self.autoRenew = try container.decode(Bool?.self, forKey: .autoRenew)
    }
    if container.contains(.readyForDnsRecordManagement) {
        self.readyForDnsRecordManagement = try container.decode(Bool?.self, forKey: .readyForDnsRecordManagement)
    }
    if container.contains(.managedHostNames) {
        self.managedHostNames = try container.decode([HostNameData?]?.self, forKey: .managedHostNames)
    }
    if container.contains(.consent) {
        self.consent = try container.decode(DomainPurchaseConsentData?.self, forKey: .consent)
    }
    if container.contains(.domainNotRenewableReasons) {
        self.domainNotRenewableReasons = try container.decode([String?]?.self, forKey: .domainNotRenewableReasons)
    }
    if container.contains(.dnsType) {
        self.dnsType = try container.decode(DnsTypeEnum?.self, forKey: .dnsType)
    }
    if container.contains(.dnsZoneId) {
        self.dnsZoneId = try container.decode(String?.self, forKey: .dnsZoneId)
    }
    if container.contains(.targetDnsType) {
        self.targetDnsType = try container.decode(DnsTypeEnum?.self, forKey: .targetDnsType)
    }
    if container.contains(.authCode) {
        self.authCode = try container.decode(String?.self, forKey: .authCode)
    }
    if var pageDecoder = decoder as? PageDecoder  {
      if pageDecoder.isPagedData,
        let nextLinkName = pageDecoder.nextLinkName {
          pageDecoder.nextLink = try UnknownCodingKey.decodeStringForKey(decoder: decoder, keyForDecode: nextLinkName)
      }
    }
  }

  public func encode(to encoder: Encoder) throws {
    var container = encoder.container(keyedBy: CodingKeys.self)
    if self.contactAdmin != nil {try container.encode(self.contactAdmin as! ContactData?, forKey: .contactAdmin)}
    if self.contactBilling != nil {try container.encode(self.contactBilling as! ContactData?, forKey: .contactBilling)}
    if self.contactRegistrant != nil {try container.encode(self.contactRegistrant as! ContactData?, forKey: .contactRegistrant)}
    if self.contactTech != nil {try container.encode(self.contactTech as! ContactData?, forKey: .contactTech)}
    if self.registrationStatus != nil {try container.encode(self.registrationStatus, forKey: .registrationStatus)}
    if self.provisioningState != nil {try container.encode(self.provisioningState, forKey: .provisioningState)}
    if self.nameServers != nil {try container.encode(self.nameServers as! [String]?, forKey: .nameServers)}
    if self.privacy != nil {try container.encode(self.privacy, forKey: .privacy)}
    if self.createdTime != nil {
        try container.encode(DateConverter.toString(date: self.createdTime!, format: .dateTime), forKey: .createdTime)
    }
    if self.expirationTime != nil {
        try container.encode(DateConverter.toString(date: self.expirationTime!, format: .dateTime), forKey: .expirationTime)
    }
    if self.lastRenewedTime != nil {
        try container.encode(DateConverter.toString(date: self.lastRenewedTime!, format: .dateTime), forKey: .lastRenewedTime)
    }
    if self.autoRenew != nil {try container.encode(self.autoRenew, forKey: .autoRenew)}
    if self.readyForDnsRecordManagement != nil {try container.encode(self.readyForDnsRecordManagement, forKey: .readyForDnsRecordManagement)}
    if self.managedHostNames != nil {try container.encode(self.managedHostNames as! [HostNameData?]?, forKey: .managedHostNames)}
    if self.consent != nil {try container.encode(self.consent as! DomainPurchaseConsentData?, forKey: .consent)}
    if self.domainNotRenewableReasons != nil {try container.encode(self.domainNotRenewableReasons as! [String?]?, forKey: .domainNotRenewableReasons)}
    if self.dnsType != nil {try container.encode(self.dnsType, forKey: .dnsType)}
    if self.dnsZoneId != nil {try container.encode(self.dnsZoneId, forKey: .dnsZoneId)}
    if self.targetDnsType != nil {try container.encode(self.targetDnsType, forKey: .targetDnsType)}
    if self.authCode != nil {try container.encode(self.authCode, forKey: .authCode)}
  }
}

extension DataFactory {
  public static func createDomainPatchResourcePropertiesProtocol() -> DomainPatchResourcePropertiesProtocol {
    return DomainPatchResourcePropertiesData()
  }
}
