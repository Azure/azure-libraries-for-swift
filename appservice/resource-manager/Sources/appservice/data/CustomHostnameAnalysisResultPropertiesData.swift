// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
import Foundation
import azureSwiftRuntime
internal struct CustomHostnameAnalysisResultPropertiesData : CustomHostnameAnalysisResultPropertiesProtocol {
    public var isHostnameAlreadyVerified: Bool?
    public var customDomainVerificationTest: DnsVerificationTestResultEnum?
    public var customDomainVerificationFailureInfo: ErrorEntityProtocol?
    public var hasConflictOnScaleUnit: Bool?
    public var hasConflictAcrossSubscription: Bool?
    public var conflictingAppResourceId: String?
    public var cNameRecords: [String]?
    public var txtRecords: [String]?
    public var aRecords: [String]?
    public var alternateCNameRecords: [String]?
    public var alternateTxtRecords: [String]?

        enum CodingKeys: String, CodingKey {case isHostnameAlreadyVerified = "isHostnameAlreadyVerified"
        case customDomainVerificationTest = "customDomainVerificationTest"
        case customDomainVerificationFailureInfo = "customDomainVerificationFailureInfo"
        case hasConflictOnScaleUnit = "hasConflictOnScaleUnit"
        case hasConflictAcrossSubscription = "hasConflictAcrossSubscription"
        case conflictingAppResourceId = "conflictingAppResourceId"
        case cNameRecords = "cNameRecords"
        case txtRecords = "txtRecords"
        case aRecords = "aRecords"
        case alternateCNameRecords = "alternateCNameRecords"
        case alternateTxtRecords = "alternateTxtRecords"
        }

  public init()  {
  }

  public init(from decoder: Decoder) throws {
    let container = try decoder.container(keyedBy: CodingKeys.self)
      if container.contains(.isHostnameAlreadyVerified) {
        self.isHostnameAlreadyVerified = try container.decode(Bool?.self, forKey: .isHostnameAlreadyVerified)
    }
    if container.contains(.customDomainVerificationTest) {
        self.customDomainVerificationTest = try container.decode(DnsVerificationTestResultEnum?.self, forKey: .customDomainVerificationTest)
    }
    if container.contains(.customDomainVerificationFailureInfo) {
        self.customDomainVerificationFailureInfo = try container.decode(ErrorEntityData?.self, forKey: .customDomainVerificationFailureInfo)
    }
    if container.contains(.hasConflictOnScaleUnit) {
        self.hasConflictOnScaleUnit = try container.decode(Bool?.self, forKey: .hasConflictOnScaleUnit)
    }
    if container.contains(.hasConflictAcrossSubscription) {
        self.hasConflictAcrossSubscription = try container.decode(Bool?.self, forKey: .hasConflictAcrossSubscription)
    }
    if container.contains(.conflictingAppResourceId) {
        self.conflictingAppResourceId = try container.decode(String?.self, forKey: .conflictingAppResourceId)
    }
    if container.contains(.cNameRecords) {
        self.cNameRecords = try container.decode([String]?.self, forKey: .cNameRecords)
    }
    if container.contains(.txtRecords) {
        self.txtRecords = try container.decode([String]?.self, forKey: .txtRecords)
    }
    if container.contains(.aRecords) {
        self.aRecords = try container.decode([String]?.self, forKey: .aRecords)
    }
    if container.contains(.alternateCNameRecords) {
        self.alternateCNameRecords = try container.decode([String]?.self, forKey: .alternateCNameRecords)
    }
    if container.contains(.alternateTxtRecords) {
        self.alternateTxtRecords = try container.decode([String]?.self, forKey: .alternateTxtRecords)
    }
    if var pageDecoder = decoder as? PageDecoder  {
      if pageDecoder.isPagedData,
        let nextLinkName = pageDecoder.nextLinkName {
          pageDecoder.nextLink = try UnknownCodingKey.decodeStringForKey(decoder: decoder, keyForDecode: nextLinkName)
      }
    }
  }

  public func encode(to encoder: Encoder) throws {
    var container = encoder.container(keyedBy: CodingKeys.self)
    if self.isHostnameAlreadyVerified != nil {try container.encode(self.isHostnameAlreadyVerified, forKey: .isHostnameAlreadyVerified)}
    if self.customDomainVerificationTest != nil {try container.encode(self.customDomainVerificationTest, forKey: .customDomainVerificationTest)}
    if self.customDomainVerificationFailureInfo != nil {try container.encode(self.customDomainVerificationFailureInfo as! ErrorEntityData?, forKey: .customDomainVerificationFailureInfo)}
    if self.hasConflictOnScaleUnit != nil {try container.encode(self.hasConflictOnScaleUnit, forKey: .hasConflictOnScaleUnit)}
    if self.hasConflictAcrossSubscription != nil {try container.encode(self.hasConflictAcrossSubscription, forKey: .hasConflictAcrossSubscription)}
    if self.conflictingAppResourceId != nil {try container.encode(self.conflictingAppResourceId, forKey: .conflictingAppResourceId)}
    if self.cNameRecords != nil {try container.encode(self.cNameRecords as! [String]?, forKey: .cNameRecords)}
    if self.txtRecords != nil {try container.encode(self.txtRecords as! [String]?, forKey: .txtRecords)}
    if self.aRecords != nil {try container.encode(self.aRecords as! [String]?, forKey: .aRecords)}
    if self.alternateCNameRecords != nil {try container.encode(self.alternateCNameRecords as! [String]?, forKey: .alternateCNameRecords)}
    if self.alternateTxtRecords != nil {try container.encode(self.alternateTxtRecords as! [String]?, forKey: .alternateTxtRecords)}
  }
}

extension DataFactory {
  public static func createCustomHostnameAnalysisResultPropertiesProtocol() -> CustomHostnameAnalysisResultPropertiesProtocol {
    return CustomHostnameAnalysisResultPropertiesData()
  }
}
