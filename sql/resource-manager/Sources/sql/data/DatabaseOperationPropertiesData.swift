// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
import Foundation
import azureSwiftRuntime
internal struct DatabaseOperationPropertiesData : DatabaseOperationPropertiesProtocol {
    public var databaseName: String?
    public var operation: String?
    public var operationFriendlyName: String?
    public var percentComplete: Int32?
    public var serverName: String?
    public var startTime: Date?
    public var state: ManagementOperationStateEnum?
    public var errorCode: Int32?
    public var errorDescription: String?
    public var errorSeverity: Int32?
    public var isUserError: Bool?
    public var estimatedCompletionTime: Date?
    public var description: String?
    public var isCancellable: Bool?

        enum CodingKeys: String, CodingKey {case databaseName = "databaseName"
        case operation = "operation"
        case operationFriendlyName = "operationFriendlyName"
        case percentComplete = "percentComplete"
        case serverName = "serverName"
        case startTime = "startTime"
        case state = "state"
        case errorCode = "errorCode"
        case errorDescription = "errorDescription"
        case errorSeverity = "errorSeverity"
        case isUserError = "isUserError"
        case estimatedCompletionTime = "estimatedCompletionTime"
        case description = "description"
        case isCancellable = "isCancellable"
        }

  public init()  {
  }

  public init(from decoder: Decoder) throws {
    let container = try decoder.container(keyedBy: CodingKeys.self)
      if container.contains(.databaseName) {
        self.databaseName = try container.decode(String?.self, forKey: .databaseName)
    }
    if container.contains(.operation) {
        self.operation = try container.decode(String?.self, forKey: .operation)
    }
    if container.contains(.operationFriendlyName) {
        self.operationFriendlyName = try container.decode(String?.self, forKey: .operationFriendlyName)
    }
    if container.contains(.percentComplete) {
        self.percentComplete = try container.decode(Int32?.self, forKey: .percentComplete)
    }
    if container.contains(.serverName) {
        self.serverName = try container.decode(String?.self, forKey: .serverName)
    }
    if container.contains(.startTime) {
        self.startTime = DateConverter.fromString(dateStr: (try container.decode(String?.self, forKey: .startTime)), format: .dateTime)
    }
    if container.contains(.state) {
        self.state = try container.decode(ManagementOperationStateEnum?.self, forKey: .state)
    }
    if container.contains(.errorCode) {
        self.errorCode = try container.decode(Int32?.self, forKey: .errorCode)
    }
    if container.contains(.errorDescription) {
        self.errorDescription = try container.decode(String?.self, forKey: .errorDescription)
    }
    if container.contains(.errorSeverity) {
        self.errorSeverity = try container.decode(Int32?.self, forKey: .errorSeverity)
    }
    if container.contains(.isUserError) {
        self.isUserError = try container.decode(Bool?.self, forKey: .isUserError)
    }
    if container.contains(.estimatedCompletionTime) {
        self.estimatedCompletionTime = DateConverter.fromString(dateStr: (try container.decode(String?.self, forKey: .estimatedCompletionTime)), format: .dateTime)
    }
    if container.contains(.description) {
        self.description = try container.decode(String?.self, forKey: .description)
    }
    if container.contains(.isCancellable) {
        self.isCancellable = try container.decode(Bool?.self, forKey: .isCancellable)
    }
    if var pageDecoder = decoder as? PageDecoder  {
      if pageDecoder.isPagedData,
        let nextLinkName = pageDecoder.nextLinkName {
          pageDecoder.nextLink = try UnknownCodingKey.decodeStringForKey(decoder: decoder, keyForDecode: nextLinkName)
      }
    }
  }

  public func encode(to encoder: Encoder) throws {
    var container = encoder.container(keyedBy: CodingKeys.self)
    if self.databaseName != nil {try container.encode(self.databaseName, forKey: .databaseName)}
    if self.operation != nil {try container.encode(self.operation, forKey: .operation)}
    if self.operationFriendlyName != nil {try container.encode(self.operationFriendlyName, forKey: .operationFriendlyName)}
    if self.percentComplete != nil {try container.encode(self.percentComplete, forKey: .percentComplete)}
    if self.serverName != nil {try container.encode(self.serverName, forKey: .serverName)}
    if self.startTime != nil {
        try container.encode(DateConverter.toString(date: self.startTime!, format: .dateTime), forKey: .startTime)
    }
    if self.state != nil {try container.encode(self.state, forKey: .state)}
    if self.errorCode != nil {try container.encode(self.errorCode, forKey: .errorCode)}
    if self.errorDescription != nil {try container.encode(self.errorDescription, forKey: .errorDescription)}
    if self.errorSeverity != nil {try container.encode(self.errorSeverity, forKey: .errorSeverity)}
    if self.isUserError != nil {try container.encode(self.isUserError, forKey: .isUserError)}
    if self.estimatedCompletionTime != nil {
        try container.encode(DateConverter.toString(date: self.estimatedCompletionTime!, format: .dateTime), forKey: .estimatedCompletionTime)
    }
    if self.description != nil {try container.encode(self.description, forKey: .description)}
    if self.isCancellable != nil {try container.encode(self.isCancellable, forKey: .isCancellable)}
  }
}

extension DataFactory {
  public static func createDatabaseOperationPropertiesProtocol() -> DatabaseOperationPropertiesProtocol {
    return DatabaseOperationPropertiesData()
  }
}
