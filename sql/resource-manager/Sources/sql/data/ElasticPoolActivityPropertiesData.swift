// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
import Foundation
import azureSwiftRuntime
internal struct ElasticPoolActivityPropertiesData : ElasticPoolActivityPropertiesProtocol {
    public var endTime: Date?
    public var errorCode: Int32?
    public var errorMessage: String?
    public var errorSeverity: Int32?
    public var operation: String?
    public var operationId: String?
    public var percentComplete: Int32?
    public var requestedDatabaseDtuMax: Int32?
    public var requestedDatabaseDtuMin: Int32?
    public var requestedDtu: Int32?
    public var requestedElasticPoolName: String?
    public var requestedStorageLimitInGB: Int64?
    public var elasticPoolName: String?
    public var serverName: String?
    public var startTime: Date?
    public var state: String?
    public var requestedStorageLimitInMB: Int32?
    public var requestedDatabaseDtuGuarantee: Int32?
    public var requestedDatabaseDtuCap: Int32?
    public var requestedDtuGuarantee: Int32?

        enum CodingKeys: String, CodingKey {case endTime = "endTime"
        case errorCode = "errorCode"
        case errorMessage = "errorMessage"
        case errorSeverity = "errorSeverity"
        case operation = "operation"
        case operationId = "operationId"
        case percentComplete = "percentComplete"
        case requestedDatabaseDtuMax = "requestedDatabaseDtuMax"
        case requestedDatabaseDtuMin = "requestedDatabaseDtuMin"
        case requestedDtu = "requestedDtu"
        case requestedElasticPoolName = "requestedElasticPoolName"
        case requestedStorageLimitInGB = "requestedStorageLimitInGB"
        case elasticPoolName = "elasticPoolName"
        case serverName = "serverName"
        case startTime = "startTime"
        case state = "state"
        case requestedStorageLimitInMB = "requestedStorageLimitInMB"
        case requestedDatabaseDtuGuarantee = "requestedDatabaseDtuGuarantee"
        case requestedDatabaseDtuCap = "requestedDatabaseDtuCap"
        case requestedDtuGuarantee = "requestedDtuGuarantee"
        }

  public init()  {
  }

  public init(from decoder: Decoder) throws {
    let container = try decoder.container(keyedBy: CodingKeys.self)
      if container.contains(.endTime) {
        self.endTime = DateConverter.fromString(dateStr: (try container.decode(String?.self, forKey: .endTime)), format: .dateTime)
    }
    if container.contains(.errorCode) {
        self.errorCode = try container.decode(Int32?.self, forKey: .errorCode)
    }
    if container.contains(.errorMessage) {
        self.errorMessage = try container.decode(String?.self, forKey: .errorMessage)
    }
    if container.contains(.errorSeverity) {
        self.errorSeverity = try container.decode(Int32?.self, forKey: .errorSeverity)
    }
    if container.contains(.operation) {
        self.operation = try container.decode(String?.self, forKey: .operation)
    }
    if container.contains(.operationId) {
        self.operationId = try container.decode(String?.self, forKey: .operationId)
    }
    if container.contains(.percentComplete) {
        self.percentComplete = try container.decode(Int32?.self, forKey: .percentComplete)
    }
    if container.contains(.requestedDatabaseDtuMax) {
        self.requestedDatabaseDtuMax = try container.decode(Int32?.self, forKey: .requestedDatabaseDtuMax)
    }
    if container.contains(.requestedDatabaseDtuMin) {
        self.requestedDatabaseDtuMin = try container.decode(Int32?.self, forKey: .requestedDatabaseDtuMin)
    }
    if container.contains(.requestedDtu) {
        self.requestedDtu = try container.decode(Int32?.self, forKey: .requestedDtu)
    }
    if container.contains(.requestedElasticPoolName) {
        self.requestedElasticPoolName = try container.decode(String?.self, forKey: .requestedElasticPoolName)
    }
    if container.contains(.requestedStorageLimitInGB) {
        self.requestedStorageLimitInGB = try container.decode(Int64?.self, forKey: .requestedStorageLimitInGB)
    }
    if container.contains(.elasticPoolName) {
        self.elasticPoolName = try container.decode(String?.self, forKey: .elasticPoolName)
    }
    if container.contains(.serverName) {
        self.serverName = try container.decode(String?.self, forKey: .serverName)
    }
    if container.contains(.startTime) {
        self.startTime = DateConverter.fromString(dateStr: (try container.decode(String?.self, forKey: .startTime)), format: .dateTime)
    }
    if container.contains(.state) {
        self.state = try container.decode(String?.self, forKey: .state)
    }
    if container.contains(.requestedStorageLimitInMB) {
        self.requestedStorageLimitInMB = try container.decode(Int32?.self, forKey: .requestedStorageLimitInMB)
    }
    if container.contains(.requestedDatabaseDtuGuarantee) {
        self.requestedDatabaseDtuGuarantee = try container.decode(Int32?.self, forKey: .requestedDatabaseDtuGuarantee)
    }
    if container.contains(.requestedDatabaseDtuCap) {
        self.requestedDatabaseDtuCap = try container.decode(Int32?.self, forKey: .requestedDatabaseDtuCap)
    }
    if container.contains(.requestedDtuGuarantee) {
        self.requestedDtuGuarantee = try container.decode(Int32?.self, forKey: .requestedDtuGuarantee)
    }
    if var pageDecoder = decoder as? PageDecoder  {
      if pageDecoder.isPagedData,
        let nextLinkName = pageDecoder.nextLinkName {
          pageDecoder.nextLink = try UnknownCodingKey.decodeStringForKey(decoder: decoder, keyForDecode: nextLinkName)
      }
    }
  }

  public func encode(to encoder: Encoder) throws {
    var container = encoder.container(keyedBy: CodingKeys.self)
    if self.endTime != nil {
        try container.encode(DateConverter.toString(date: self.endTime!, format: .dateTime), forKey: .endTime)
    }
    if self.errorCode != nil {try container.encode(self.errorCode, forKey: .errorCode)}
    if self.errorMessage != nil {try container.encode(self.errorMessage, forKey: .errorMessage)}
    if self.errorSeverity != nil {try container.encode(self.errorSeverity, forKey: .errorSeverity)}
    if self.operation != nil {try container.encode(self.operation, forKey: .operation)}
    if self.operationId != nil {try container.encode(self.operationId, forKey: .operationId)}
    if self.percentComplete != nil {try container.encode(self.percentComplete, forKey: .percentComplete)}
    if self.requestedDatabaseDtuMax != nil {try container.encode(self.requestedDatabaseDtuMax, forKey: .requestedDatabaseDtuMax)}
    if self.requestedDatabaseDtuMin != nil {try container.encode(self.requestedDatabaseDtuMin, forKey: .requestedDatabaseDtuMin)}
    if self.requestedDtu != nil {try container.encode(self.requestedDtu, forKey: .requestedDtu)}
    if self.requestedElasticPoolName != nil {try container.encode(self.requestedElasticPoolName, forKey: .requestedElasticPoolName)}
    if self.requestedStorageLimitInGB != nil {try container.encode(self.requestedStorageLimitInGB, forKey: .requestedStorageLimitInGB)}
    if self.elasticPoolName != nil {try container.encode(self.elasticPoolName, forKey: .elasticPoolName)}
    if self.serverName != nil {try container.encode(self.serverName, forKey: .serverName)}
    if self.startTime != nil {
        try container.encode(DateConverter.toString(date: self.startTime!, format: .dateTime), forKey: .startTime)
    }
    if self.state != nil {try container.encode(self.state, forKey: .state)}
    if self.requestedStorageLimitInMB != nil {try container.encode(self.requestedStorageLimitInMB, forKey: .requestedStorageLimitInMB)}
    if self.requestedDatabaseDtuGuarantee != nil {try container.encode(self.requestedDatabaseDtuGuarantee, forKey: .requestedDatabaseDtuGuarantee)}
    if self.requestedDatabaseDtuCap != nil {try container.encode(self.requestedDatabaseDtuCap, forKey: .requestedDatabaseDtuCap)}
    if self.requestedDtuGuarantee != nil {try container.encode(self.requestedDtuGuarantee, forKey: .requestedDtuGuarantee)}
  }
}

extension DataFactory {
  public static func createElasticPoolActivityPropertiesProtocol() -> ElasticPoolActivityPropertiesProtocol {
    return ElasticPoolActivityPropertiesData()
  }
}
