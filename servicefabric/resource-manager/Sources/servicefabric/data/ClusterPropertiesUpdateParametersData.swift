// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
import Foundation
import azureSwiftRuntime
internal struct ClusterPropertiesUpdateParametersData : ClusterPropertiesUpdateParametersProtocol {
    public var reliabilityLevel: ReliabilityLevel1Enum?
    public var upgradeMode: UpgradeMode1Enum?
    public var clusterCodeVersion: String?
    public var certificate: CertificateDescriptionProtocol?
    public var clientCertificateThumbprints: [ClientCertificateThumbprintProtocol?]?
    public var clientCertificateCommonNames: [ClientCertificateCommonNameProtocol?]?
    public var fabricSettings: [SettingsSectionDescriptionProtocol?]?
    public var reverseProxyCertificate: CertificateDescriptionProtocol?
    public var nodeTypes: [NodeTypeDescriptionProtocol?]?
    public var upgradeDescription: ClusterUpgradePolicyProtocol?
    public var addOnFeatures: [String?]?

        enum CodingKeys: String, CodingKey {case reliabilityLevel = "reliabilityLevel"
        case upgradeMode = "upgradeMode"
        case clusterCodeVersion = "clusterCodeVersion"
        case certificate = "certificate"
        case clientCertificateThumbprints = "clientCertificateThumbprints"
        case clientCertificateCommonNames = "clientCertificateCommonNames"
        case fabricSettings = "fabricSettings"
        case reverseProxyCertificate = "reverseProxyCertificate"
        case nodeTypes = "nodeTypes"
        case upgradeDescription = "upgradeDescription"
        case addOnFeatures = "addOnFeatures"
        }

  public init()  {
  }

  public init(from decoder: Decoder) throws {
    let container = try decoder.container(keyedBy: CodingKeys.self)
      if container.contains(.reliabilityLevel) {
        self.reliabilityLevel = try container.decode(ReliabilityLevel1Enum?.self, forKey: .reliabilityLevel)
    }
    if container.contains(.upgradeMode) {
        self.upgradeMode = try container.decode(UpgradeMode1Enum?.self, forKey: .upgradeMode)
    }
    if container.contains(.clusterCodeVersion) {
        self.clusterCodeVersion = try container.decode(String?.self, forKey: .clusterCodeVersion)
    }
    if container.contains(.certificate) {
        self.certificate = try container.decode(CertificateDescriptionData?.self, forKey: .certificate)
    }
    if container.contains(.clientCertificateThumbprints) {
        self.clientCertificateThumbprints = try container.decode([ClientCertificateThumbprintData?]?.self, forKey: .clientCertificateThumbprints)
    }
    if container.contains(.clientCertificateCommonNames) {
        self.clientCertificateCommonNames = try container.decode([ClientCertificateCommonNameData?]?.self, forKey: .clientCertificateCommonNames)
    }
    if container.contains(.fabricSettings) {
        self.fabricSettings = try container.decode([SettingsSectionDescriptionData?]?.self, forKey: .fabricSettings)
    }
    if container.contains(.reverseProxyCertificate) {
        self.reverseProxyCertificate = try container.decode(CertificateDescriptionData?.self, forKey: .reverseProxyCertificate)
    }
    if container.contains(.nodeTypes) {
        self.nodeTypes = try container.decode([NodeTypeDescriptionData?]?.self, forKey: .nodeTypes)
    }
    if container.contains(.upgradeDescription) {
        self.upgradeDescription = try container.decode(ClusterUpgradePolicyData?.self, forKey: .upgradeDescription)
    }
    if container.contains(.addOnFeatures) {
        self.addOnFeatures = try container.decode([String?]?.self, forKey: .addOnFeatures)
    }
    if var pageDecoder = decoder as? PageDecoder  {
      if pageDecoder.isPagedData,
        let nextLinkName = pageDecoder.nextLinkName {
          pageDecoder.nextLink = try UnknownCodingKey.decodeStringForKey(decoder: decoder, keyForDecode: nextLinkName)
      }
    }
  }

  public func encode(to encoder: Encoder) throws {
    var container = encoder.container(keyedBy: CodingKeys.self)
    if self.reliabilityLevel != nil {try container.encode(self.reliabilityLevel, forKey: .reliabilityLevel)}
    if self.upgradeMode != nil {try container.encode(self.upgradeMode, forKey: .upgradeMode)}
    if self.clusterCodeVersion != nil {try container.encode(self.clusterCodeVersion, forKey: .clusterCodeVersion)}
    if self.certificate != nil {try container.encode(self.certificate as! CertificateDescriptionData?, forKey: .certificate)}
    if self.clientCertificateThumbprints != nil {try container.encode(self.clientCertificateThumbprints as! [ClientCertificateThumbprintData?]?, forKey: .clientCertificateThumbprints)}
    if self.clientCertificateCommonNames != nil {try container.encode(self.clientCertificateCommonNames as! [ClientCertificateCommonNameData?]?, forKey: .clientCertificateCommonNames)}
    if self.fabricSettings != nil {try container.encode(self.fabricSettings as! [SettingsSectionDescriptionData?]?, forKey: .fabricSettings)}
    if self.reverseProxyCertificate != nil {try container.encode(self.reverseProxyCertificate as! CertificateDescriptionData?, forKey: .reverseProxyCertificate)}
    if self.nodeTypes != nil {try container.encode(self.nodeTypes as! [NodeTypeDescriptionData?]?, forKey: .nodeTypes)}
    if self.upgradeDescription != nil {try container.encode(self.upgradeDescription as! ClusterUpgradePolicyData?, forKey: .upgradeDescription)}
    if self.addOnFeatures != nil {try container.encode(self.addOnFeatures as! [String?]?, forKey: .addOnFeatures)}
  }
}

extension DataFactory {
  public static func createClusterPropertiesUpdateParametersProtocol() -> ClusterPropertiesUpdateParametersProtocol {
    return ClusterPropertiesUpdateParametersData()
  }
}
