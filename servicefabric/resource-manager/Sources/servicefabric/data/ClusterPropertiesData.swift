// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
import Foundation
import azureSwiftRuntime
internal struct ClusterPropertiesData : ClusterPropertiesProtocol {
    public var availableClusterVersions: [ClusterVersionDetailsProtocol?]?
    public var clusterId: String?
    public var clusterState: ClusterStateEnum?
    public var clusterEndpoint: String?
    public var clusterCodeVersion: String?
    public var certificate: CertificateDescriptionProtocol?
    public var reliabilityLevel: ReliabilityLevelEnum?
    public var upgradeMode: UpgradeModeEnum?
    public var clientCertificateThumbprints: [ClientCertificateThumbprintProtocol?]?
    public var clientCertificateCommonNames: [ClientCertificateCommonNameProtocol?]?
    public var fabricSettings: [SettingsSectionDescriptionProtocol?]?
    public var reverseProxyCertificate: CertificateDescriptionProtocol?
    public var managementEndpoint: String
    public var nodeTypes: [NodeTypeDescriptionProtocol]
    public var azureActiveDirectory: AzureActiveDirectoryProtocol?
    public var provisioningState: ProvisioningStateEnum?
    public var vmImage: String?
    public var diagnosticsStorageAccountConfig: DiagnosticsStorageAccountConfigProtocol?
    public var upgradeDescription: ClusterUpgradePolicyProtocol?
    public var addOnFeatures: [String?]?

        enum CodingKeys: String, CodingKey {case availableClusterVersions = "availableClusterVersions"
        case clusterId = "clusterId"
        case clusterState = "clusterState"
        case clusterEndpoint = "clusterEndpoint"
        case clusterCodeVersion = "clusterCodeVersion"
        case certificate = "certificate"
        case reliabilityLevel = "reliabilityLevel"
        case upgradeMode = "upgradeMode"
        case clientCertificateThumbprints = "clientCertificateThumbprints"
        case clientCertificateCommonNames = "clientCertificateCommonNames"
        case fabricSettings = "fabricSettings"
        case reverseProxyCertificate = "reverseProxyCertificate"
        case managementEndpoint = "managementEndpoint"
        case nodeTypes = "nodeTypes"
        case azureActiveDirectory = "azureActiveDirectory"
        case provisioningState = "provisioningState"
        case vmImage = "vmImage"
        case diagnosticsStorageAccountConfig = "diagnosticsStorageAccountConfig"
        case upgradeDescription = "upgradeDescription"
        case addOnFeatures = "addOnFeatures"
        }

  public init(managementEndpoint: String, nodeTypes: [NodeTypeDescriptionProtocol])  {
    self.managementEndpoint = managementEndpoint
    self.nodeTypes = nodeTypes
  }

  public init(from decoder: Decoder) throws {
    let container = try decoder.container(keyedBy: CodingKeys.self)
      if container.contains(.availableClusterVersions) {
        self.availableClusterVersions = try container.decode([ClusterVersionDetailsData?]?.self, forKey: .availableClusterVersions)
    }
    if container.contains(.clusterId) {
        self.clusterId = try container.decode(String?.self, forKey: .clusterId)
    }
    if container.contains(.clusterState) {
        self.clusterState = try container.decode(ClusterStateEnum?.self, forKey: .clusterState)
    }
    if container.contains(.clusterEndpoint) {
        self.clusterEndpoint = try container.decode(String?.self, forKey: .clusterEndpoint)
    }
    if container.contains(.clusterCodeVersion) {
        self.clusterCodeVersion = try container.decode(String?.self, forKey: .clusterCodeVersion)
    }
    if container.contains(.certificate) {
        self.certificate = try container.decode(CertificateDescriptionData?.self, forKey: .certificate)
    }
    if container.contains(.reliabilityLevel) {
        self.reliabilityLevel = try container.decode(ReliabilityLevelEnum?.self, forKey: .reliabilityLevel)
    }
    if container.contains(.upgradeMode) {
        self.upgradeMode = try container.decode(UpgradeModeEnum?.self, forKey: .upgradeMode)
    }
    if container.contains(.clientCertificateThumbprints) {
        self.clientCertificateThumbprints = try container.decode([ClientCertificateThumbprintData?]?.self, forKey: .clientCertificateThumbprints)
    }
    if container.contains(.clientCertificateCommonNames) {
        self.clientCertificateCommonNames = try container.decode([ClientCertificateCommonNameData?]?.self, forKey: .clientCertificateCommonNames)
    }
    if container.contains(.fabricSettings) {
        self.fabricSettings = try container.decode([SettingsSectionDescriptionData?]?.self, forKey: .fabricSettings)
    }
    if container.contains(.reverseProxyCertificate) {
        self.reverseProxyCertificate = try container.decode(CertificateDescriptionData?.self, forKey: .reverseProxyCertificate)
    }
    self.managementEndpoint = try container.decode(String.self, forKey: .managementEndpoint)
    self.nodeTypes = try container.decode([NodeTypeDescriptionData].self, forKey: .nodeTypes)
    if container.contains(.azureActiveDirectory) {
        self.azureActiveDirectory = try container.decode(AzureActiveDirectoryData?.self, forKey: .azureActiveDirectory)
    }
    if container.contains(.provisioningState) {
        self.provisioningState = try container.decode(ProvisioningStateEnum?.self, forKey: .provisioningState)
    }
    if container.contains(.vmImage) {
        self.vmImage = try container.decode(String?.self, forKey: .vmImage)
    }
    if container.contains(.diagnosticsStorageAccountConfig) {
        self.diagnosticsStorageAccountConfig = try container.decode(DiagnosticsStorageAccountConfigData?.self, forKey: .diagnosticsStorageAccountConfig)
    }
    if container.contains(.upgradeDescription) {
        self.upgradeDescription = try container.decode(ClusterUpgradePolicyData?.self, forKey: .upgradeDescription)
    }
    if container.contains(.addOnFeatures) {
        self.addOnFeatures = try container.decode([String?]?.self, forKey: .addOnFeatures)
    }
    if var pageDecoder = decoder as? PageDecoder  {
      if pageDecoder.isPagedData,
        let nextLinkName = pageDecoder.nextLinkName {
          pageDecoder.nextLink = try UnknownCodingKey.decodeStringForKey(decoder: decoder, keyForDecode: nextLinkName)
      }
    }
  }

  public func encode(to encoder: Encoder) throws {
    var container = encoder.container(keyedBy: CodingKeys.self)
    if self.availableClusterVersions != nil {try container.encode(self.availableClusterVersions as! [ClusterVersionDetailsData?]?, forKey: .availableClusterVersions)}
    if self.clusterId != nil {try container.encode(self.clusterId, forKey: .clusterId)}
    if self.clusterState != nil {try container.encode(self.clusterState, forKey: .clusterState)}
    if self.clusterEndpoint != nil {try container.encode(self.clusterEndpoint, forKey: .clusterEndpoint)}
    if self.clusterCodeVersion != nil {try container.encode(self.clusterCodeVersion, forKey: .clusterCodeVersion)}
    if self.certificate != nil {try container.encode(self.certificate as! CertificateDescriptionData?, forKey: .certificate)}
    if self.reliabilityLevel != nil {try container.encode(self.reliabilityLevel, forKey: .reliabilityLevel)}
    if self.upgradeMode != nil {try container.encode(self.upgradeMode, forKey: .upgradeMode)}
    if self.clientCertificateThumbprints != nil {try container.encode(self.clientCertificateThumbprints as! [ClientCertificateThumbprintData?]?, forKey: .clientCertificateThumbprints)}
    if self.clientCertificateCommonNames != nil {try container.encode(self.clientCertificateCommonNames as! [ClientCertificateCommonNameData?]?, forKey: .clientCertificateCommonNames)}
    if self.fabricSettings != nil {try container.encode(self.fabricSettings as! [SettingsSectionDescriptionData?]?, forKey: .fabricSettings)}
    if self.reverseProxyCertificate != nil {try container.encode(self.reverseProxyCertificate as! CertificateDescriptionData?, forKey: .reverseProxyCertificate)}
    try container.encode(self.managementEndpoint, forKey: .managementEndpoint)
    try container.encode(self.nodeTypes as! [NodeTypeDescriptionData], forKey: .nodeTypes)
    if self.azureActiveDirectory != nil {try container.encode(self.azureActiveDirectory as! AzureActiveDirectoryData?, forKey: .azureActiveDirectory)}
    if self.provisioningState != nil {try container.encode(self.provisioningState, forKey: .provisioningState)}
    if self.vmImage != nil {try container.encode(self.vmImage, forKey: .vmImage)}
    if self.diagnosticsStorageAccountConfig != nil {try container.encode(self.diagnosticsStorageAccountConfig as! DiagnosticsStorageAccountConfigData?, forKey: .diagnosticsStorageAccountConfig)}
    if self.upgradeDescription != nil {try container.encode(self.upgradeDescription as! ClusterUpgradePolicyData?, forKey: .upgradeDescription)}
    if self.addOnFeatures != nil {try container.encode(self.addOnFeatures as! [String?]?, forKey: .addOnFeatures)}
  }
}

extension DataFactory {
  public static func createClusterPropertiesProtocol(managementEndpoint: String, nodeTypes: [NodeTypeDescriptionProtocol]) -> ClusterPropertiesProtocol {
    return ClusterPropertiesData(managementEndpoint: managementEndpoint, nodeTypes: nodeTypes)
  }
}
