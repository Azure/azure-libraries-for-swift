// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
import Foundation
import azureSwiftRuntime
internal struct JobPropertiesData : JobPropertiesProtocol {
    public var experimentName: String?
    public var priority: Int32?
    public var cluster: ResourceIdProtocol?
    public var nodeCount: Int32?
    public var containerSettings: ContainerSettingsProtocol?
    public var toolType: ToolTypeEnum?
    public var cntkSettings: CNTKsettingsProtocol?
    public var tensorFlowSettings: TensorFlowSettingsProtocol?
    public var caffeSettings: CaffeSettingsProtocol?
    public var chainerSettings: ChainerSettingsProtocol?
    public var customToolkitSettings: CustomToolkitSettingsProtocol?
    public var jobPreparation: JobPreparationProtocol?
    public var stdOutErrPathPrefix: String?
    public var inputDirectories: [InputDirectoryProtocol?]?
    public var outputDirectories: [OutputDirectoryProtocol?]?
    public var environmentVariables: [EnvironmentSettingProtocol?]?
    public var constraints: JobPropertiesConstraintsProtocol?
    public var creationTime: Date?
    public var provisioningState: ProvisioningStateEnum?
    public var provisioningStateTransitionTime: Date?
    public var executionState: ExecutionStateEnum?
    public var executionStateTransitionTime: Date?
    public var executionInfo: JobPropertiesExecutionInfoProtocol?

        enum CodingKeys: String, CodingKey {case experimentName = "experimentName"
        case priority = "priority"
        case cluster = "cluster"
        case nodeCount = "nodeCount"
        case containerSettings = "containerSettings"
        case toolType = "toolType"
        case cntkSettings = "cntkSettings"
        case tensorFlowSettings = "tensorFlowSettings"
        case caffeSettings = "caffeSettings"
        case chainerSettings = "chainerSettings"
        case customToolkitSettings = "customToolkitSettings"
        case jobPreparation = "jobPreparation"
        case stdOutErrPathPrefix = "stdOutErrPathPrefix"
        case inputDirectories = "inputDirectories"
        case outputDirectories = "outputDirectories"
        case environmentVariables = "environmentVariables"
        case constraints = "constraints"
        case creationTime = "creationTime"
        case provisioningState = "provisioningState"
        case provisioningStateTransitionTime = "provisioningStateTransitionTime"
        case executionState = "executionState"
        case executionStateTransitionTime = "executionStateTransitionTime"
        case executionInfo = "executionInfo"
        }

  public init()  {
  }

  public init(from decoder: Decoder) throws {
    let container = try decoder.container(keyedBy: CodingKeys.self)
      if container.contains(.experimentName) {
        self.experimentName = try container.decode(String?.self, forKey: .experimentName)
    }
    if container.contains(.priority) {
        self.priority = try container.decode(Int32?.self, forKey: .priority)
    }
    if container.contains(.cluster) {
        self.cluster = try container.decode(ResourceIdData?.self, forKey: .cluster)
    }
    if container.contains(.nodeCount) {
        self.nodeCount = try container.decode(Int32?.self, forKey: .nodeCount)
    }
    if container.contains(.containerSettings) {
        self.containerSettings = try container.decode(ContainerSettingsData?.self, forKey: .containerSettings)
    }
    if container.contains(.toolType) {
        self.toolType = try container.decode(ToolTypeEnum?.self, forKey: .toolType)
    }
    if container.contains(.cntkSettings) {
        self.cntkSettings = try container.decode(CNTKsettingsData?.self, forKey: .cntkSettings)
    }
    if container.contains(.tensorFlowSettings) {
        self.tensorFlowSettings = try container.decode(TensorFlowSettingsData?.self, forKey: .tensorFlowSettings)
    }
    if container.contains(.caffeSettings) {
        self.caffeSettings = try container.decode(CaffeSettingsData?.self, forKey: .caffeSettings)
    }
    if container.contains(.chainerSettings) {
        self.chainerSettings = try container.decode(ChainerSettingsData?.self, forKey: .chainerSettings)
    }
    if container.contains(.customToolkitSettings) {
        self.customToolkitSettings = try container.decode(CustomToolkitSettingsData?.self, forKey: .customToolkitSettings)
    }
    if container.contains(.jobPreparation) {
        self.jobPreparation = try container.decode(JobPreparationData?.self, forKey: .jobPreparation)
    }
    if container.contains(.stdOutErrPathPrefix) {
        self.stdOutErrPathPrefix = try container.decode(String?.self, forKey: .stdOutErrPathPrefix)
    }
    if container.contains(.inputDirectories) {
        self.inputDirectories = try container.decode([InputDirectoryData?]?.self, forKey: .inputDirectories)
    }
    if container.contains(.outputDirectories) {
        self.outputDirectories = try container.decode([OutputDirectoryData?]?.self, forKey: .outputDirectories)
    }
    if container.contains(.environmentVariables) {
        self.environmentVariables = try container.decode([EnvironmentSettingData?]?.self, forKey: .environmentVariables)
    }
    if container.contains(.constraints) {
        self.constraints = try container.decode(JobPropertiesConstraintsData?.self, forKey: .constraints)
    }
    if container.contains(.creationTime) {
        self.creationTime = DateConverter.fromString(dateStr: (try container.decode(String?.self, forKey: .creationTime)), format: .dateTime)
    }
    if container.contains(.provisioningState) {
        self.provisioningState = try container.decode(ProvisioningStateEnum?.self, forKey: .provisioningState)
    }
    if container.contains(.provisioningStateTransitionTime) {
        self.provisioningStateTransitionTime = DateConverter.fromString(dateStr: (try container.decode(String?.self, forKey: .provisioningStateTransitionTime)), format: .dateTime)
    }
    if container.contains(.executionState) {
        self.executionState = try container.decode(ExecutionStateEnum?.self, forKey: .executionState)
    }
    if container.contains(.executionStateTransitionTime) {
        self.executionStateTransitionTime = DateConverter.fromString(dateStr: (try container.decode(String?.self, forKey: .executionStateTransitionTime)), format: .dateTime)
    }
    if container.contains(.executionInfo) {
        self.executionInfo = try container.decode(JobPropertiesExecutionInfoData?.self, forKey: .executionInfo)
    }
    if var pageDecoder = decoder as? PageDecoder  {
      if pageDecoder.isPagedData,
        let nextLinkName = pageDecoder.nextLinkName {
          pageDecoder.nextLink = try UnknownCodingKey.decodeStringForKey(decoder: decoder, keyForDecode: nextLinkName)
      }
    }
  }

  public func encode(to encoder: Encoder) throws {
    var container = encoder.container(keyedBy: CodingKeys.self)
    if self.experimentName != nil {try container.encode(self.experimentName, forKey: .experimentName)}
    if self.priority != nil {try container.encode(self.priority, forKey: .priority)}
    if self.cluster != nil {try container.encode(self.cluster as! ResourceIdData?, forKey: .cluster)}
    if self.nodeCount != nil {try container.encode(self.nodeCount, forKey: .nodeCount)}
    if self.containerSettings != nil {try container.encode(self.containerSettings as! ContainerSettingsData?, forKey: .containerSettings)}
    if self.toolType != nil {try container.encode(self.toolType, forKey: .toolType)}
    if self.cntkSettings != nil {try container.encode(self.cntkSettings as! CNTKsettingsData?, forKey: .cntkSettings)}
    if self.tensorFlowSettings != nil {try container.encode(self.tensorFlowSettings as! TensorFlowSettingsData?, forKey: .tensorFlowSettings)}
    if self.caffeSettings != nil {try container.encode(self.caffeSettings as! CaffeSettingsData?, forKey: .caffeSettings)}
    if self.chainerSettings != nil {try container.encode(self.chainerSettings as! ChainerSettingsData?, forKey: .chainerSettings)}
    if self.customToolkitSettings != nil {try container.encode(self.customToolkitSettings as! CustomToolkitSettingsData?, forKey: .customToolkitSettings)}
    if self.jobPreparation != nil {try container.encode(self.jobPreparation as! JobPreparationData?, forKey: .jobPreparation)}
    if self.stdOutErrPathPrefix != nil {try container.encode(self.stdOutErrPathPrefix, forKey: .stdOutErrPathPrefix)}
    if self.inputDirectories != nil {try container.encode(self.inputDirectories as! [InputDirectoryData?]?, forKey: .inputDirectories)}
    if self.outputDirectories != nil {try container.encode(self.outputDirectories as! [OutputDirectoryData?]?, forKey: .outputDirectories)}
    if self.environmentVariables != nil {try container.encode(self.environmentVariables as! [EnvironmentSettingData?]?, forKey: .environmentVariables)}
    if self.constraints != nil {try container.encode(self.constraints as! JobPropertiesConstraintsData?, forKey: .constraints)}
    if self.creationTime != nil {
        try container.encode(DateConverter.toString(date: self.creationTime!, format: .dateTime), forKey: .creationTime)
    }
    if self.provisioningState != nil {try container.encode(self.provisioningState, forKey: .provisioningState)}
    if self.provisioningStateTransitionTime != nil {
        try container.encode(DateConverter.toString(date: self.provisioningStateTransitionTime!, format: .dateTime), forKey: .provisioningStateTransitionTime)
    }
    if self.executionState != nil {try container.encode(self.executionState, forKey: .executionState)}
    if self.executionStateTransitionTime != nil {
        try container.encode(DateConverter.toString(date: self.executionStateTransitionTime!, format: .dateTime), forKey: .executionStateTransitionTime)
    }
    if self.executionInfo != nil {try container.encode(self.executionInfo as! JobPropertiesExecutionInfoData?, forKey: .executionInfo)}
  }
}

extension DataFactory {
  public static func createJobPropertiesProtocol() -> JobPropertiesProtocol {
    return JobPropertiesData()
  }
}
