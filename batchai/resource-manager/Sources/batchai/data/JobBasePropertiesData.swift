// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
import Foundation
import azureSwiftRuntime
internal struct JobBasePropertiesData : JobBasePropertiesProtocol {
    public var experimentName: String?
    public var priority: Int32?
    public var cluster: ResourceIdProtocol
    public var nodeCount: Int32
    public var containerSettings: ContainerSettingsProtocol?
    public var cntkSettings: CNTKsettingsProtocol?
    public var tensorFlowSettings: TensorFlowSettingsProtocol?
    public var caffeSettings: CaffeSettingsProtocol?
    public var caffe2Settings: Caffe2SettingsProtocol?
    public var chainerSettings: ChainerSettingsProtocol?
    public var customToolkitSettings: CustomToolkitSettingsProtocol?
    public var jobPreparation: JobPreparationProtocol?
    public var stdOutErrPathPrefix: String
    public var inputDirectories: [InputDirectoryProtocol?]?
    public var outputDirectories: [OutputDirectoryProtocol?]?
    public var environmentVariables: [EnvironmentSettingProtocol?]?
    public var constraints: JobBasePropertiesConstraintsProtocol?

        enum CodingKeys: String, CodingKey {case experimentName = "experimentName"
        case priority = "priority"
        case cluster = "cluster"
        case nodeCount = "nodeCount"
        case containerSettings = "containerSettings"
        case cntkSettings = "cntkSettings"
        case tensorFlowSettings = "tensorFlowSettings"
        case caffeSettings = "caffeSettings"
        case caffe2Settings = "caffe2Settings"
        case chainerSettings = "chainerSettings"
        case customToolkitSettings = "customToolkitSettings"
        case jobPreparation = "jobPreparation"
        case stdOutErrPathPrefix = "stdOutErrPathPrefix"
        case inputDirectories = "inputDirectories"
        case outputDirectories = "outputDirectories"
        case environmentVariables = "environmentVariables"
        case constraints = "constraints"
        }

  public init(cluster: ResourceIdProtocol, nodeCount: Int32, stdOutErrPathPrefix: String)  {
    self.cluster = cluster
    self.nodeCount = nodeCount
    self.stdOutErrPathPrefix = stdOutErrPathPrefix
  }

  public init(from decoder: Decoder) throws {
    let container = try decoder.container(keyedBy: CodingKeys.self)
      if container.contains(.experimentName) {
        self.experimentName = try container.decode(String?.self, forKey: .experimentName)
    }
    if container.contains(.priority) {
        self.priority = try container.decode(Int32?.self, forKey: .priority)
    }
    self.cluster = try container.decode(ResourceIdData.self, forKey: .cluster)
    self.nodeCount = try container.decode(Int32.self, forKey: .nodeCount)
    if container.contains(.containerSettings) {
        self.containerSettings = try container.decode(ContainerSettingsData?.self, forKey: .containerSettings)
    }
    if container.contains(.cntkSettings) {
        self.cntkSettings = try container.decode(CNTKsettingsData?.self, forKey: .cntkSettings)
    }
    if container.contains(.tensorFlowSettings) {
        self.tensorFlowSettings = try container.decode(TensorFlowSettingsData?.self, forKey: .tensorFlowSettings)
    }
    if container.contains(.caffeSettings) {
        self.caffeSettings = try container.decode(CaffeSettingsData?.self, forKey: .caffeSettings)
    }
    if container.contains(.caffe2Settings) {
        self.caffe2Settings = try container.decode(Caffe2SettingsData?.self, forKey: .caffe2Settings)
    }
    if container.contains(.chainerSettings) {
        self.chainerSettings = try container.decode(ChainerSettingsData?.self, forKey: .chainerSettings)
    }
    if container.contains(.customToolkitSettings) {
        self.customToolkitSettings = try container.decode(CustomToolkitSettingsData?.self, forKey: .customToolkitSettings)
    }
    if container.contains(.jobPreparation) {
        self.jobPreparation = try container.decode(JobPreparationData?.self, forKey: .jobPreparation)
    }
    self.stdOutErrPathPrefix = try container.decode(String.self, forKey: .stdOutErrPathPrefix)
    if container.contains(.inputDirectories) {
        self.inputDirectories = try container.decode([InputDirectoryData?]?.self, forKey: .inputDirectories)
    }
    if container.contains(.outputDirectories) {
        self.outputDirectories = try container.decode([OutputDirectoryData?]?.self, forKey: .outputDirectories)
    }
    if container.contains(.environmentVariables) {
        self.environmentVariables = try container.decode([EnvironmentSettingData?]?.self, forKey: .environmentVariables)
    }
    if container.contains(.constraints) {
        self.constraints = try container.decode(JobBasePropertiesConstraintsData?.self, forKey: .constraints)
    }
    if var pageDecoder = decoder as? PageDecoder  {
      if pageDecoder.isPagedData,
        let nextLinkName = pageDecoder.nextLinkName {
          pageDecoder.nextLink = try UnknownCodingKey.decodeStringForKey(decoder: decoder, keyForDecode: nextLinkName)
      }
    }
  }

  public func encode(to encoder: Encoder) throws {
    var container = encoder.container(keyedBy: CodingKeys.self)
    if self.experimentName != nil {try container.encode(self.experimentName, forKey: .experimentName)}
    if self.priority != nil {try container.encode(self.priority, forKey: .priority)}
    try container.encode(self.cluster as! ResourceIdData, forKey: .cluster)
    try container.encode(self.nodeCount, forKey: .nodeCount)
    if self.containerSettings != nil {try container.encode(self.containerSettings as! ContainerSettingsData?, forKey: .containerSettings)}
    if self.cntkSettings != nil {try container.encode(self.cntkSettings as! CNTKsettingsData?, forKey: .cntkSettings)}
    if self.tensorFlowSettings != nil {try container.encode(self.tensorFlowSettings as! TensorFlowSettingsData?, forKey: .tensorFlowSettings)}
    if self.caffeSettings != nil {try container.encode(self.caffeSettings as! CaffeSettingsData?, forKey: .caffeSettings)}
    if self.caffe2Settings != nil {try container.encode(self.caffe2Settings as! Caffe2SettingsData?, forKey: .caffe2Settings)}
    if self.chainerSettings != nil {try container.encode(self.chainerSettings as! ChainerSettingsData?, forKey: .chainerSettings)}
    if self.customToolkitSettings != nil {try container.encode(self.customToolkitSettings as! CustomToolkitSettingsData?, forKey: .customToolkitSettings)}
    if self.jobPreparation != nil {try container.encode(self.jobPreparation as! JobPreparationData?, forKey: .jobPreparation)}
    try container.encode(self.stdOutErrPathPrefix, forKey: .stdOutErrPathPrefix)
    if self.inputDirectories != nil {try container.encode(self.inputDirectories as! [InputDirectoryData?]?, forKey: .inputDirectories)}
    if self.outputDirectories != nil {try container.encode(self.outputDirectories as! [OutputDirectoryData?]?, forKey: .outputDirectories)}
    if self.environmentVariables != nil {try container.encode(self.environmentVariables as! [EnvironmentSettingData?]?, forKey: .environmentVariables)}
    if self.constraints != nil {try container.encode(self.constraints as! JobBasePropertiesConstraintsData?, forKey: .constraints)}
  }
}

extension DataFactory {
  public static func createJobBasePropertiesProtocol(cluster: ResourceIdProtocol, nodeCount: Int32, stdOutErrPathPrefix: String) -> JobBasePropertiesProtocol {
    return JobBasePropertiesData(cluster: cluster, nodeCount: nodeCount, stdOutErrPathPrefix: stdOutErrPathPrefix)
  }
}
