// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
import Foundation
import azureSwiftRuntime
internal struct MonitorConfigData : MonitorConfigProtocol {
    public var profileMonitorStatus: ProfileMonitorStatusEnum?
    public var _protocol: MonitorProtocolEnum?
    public var port: Int64?
    public var path: String?
    public var intervalInSeconds: Int64?
    public var timeoutInSeconds: Int64?
    public var toleratedNumberOfFailures: Int64?

        enum CodingKeys: String, CodingKey {case profileMonitorStatus = "profileMonitorStatus"
        case _protocol = "protocol"
        case port = "port"
        case path = "path"
        case intervalInSeconds = "intervalInSeconds"
        case timeoutInSeconds = "timeoutInSeconds"
        case toleratedNumberOfFailures = "toleratedNumberOfFailures"
        }

  public init()  {
  }

  public init(from decoder: Decoder) throws {
    let container = try decoder.container(keyedBy: CodingKeys.self)
      if container.contains(.profileMonitorStatus) {
        self.profileMonitorStatus = try container.decode(ProfileMonitorStatusEnum?.self, forKey: .profileMonitorStatus)
    }
    if container.contains(._protocol) {
        self._protocol = try container.decode(MonitorProtocolEnum?.self, forKey: ._protocol)
    }
    if container.contains(.port) {
        self.port = try container.decode(Int64?.self, forKey: .port)
    }
    if container.contains(.path) {
        self.path = try container.decode(String?.self, forKey: .path)
    }
    if container.contains(.intervalInSeconds) {
        self.intervalInSeconds = try container.decode(Int64?.self, forKey: .intervalInSeconds)
    }
    if container.contains(.timeoutInSeconds) {
        self.timeoutInSeconds = try container.decode(Int64?.self, forKey: .timeoutInSeconds)
    }
    if container.contains(.toleratedNumberOfFailures) {
        self.toleratedNumberOfFailures = try container.decode(Int64?.self, forKey: .toleratedNumberOfFailures)
    }
    if var pageDecoder = decoder as? PageDecoder  {
      if pageDecoder.isPagedData,
        let nextLinkName = pageDecoder.nextLinkName {
          pageDecoder.nextLink = try UnknownCodingKey.decodeStringForKey(decoder: decoder, keyForDecode: nextLinkName)
      }
    }
  }

  public func encode(to encoder: Encoder) throws {
    var container = encoder.container(keyedBy: CodingKeys.self)
    if self.profileMonitorStatus != nil {try container.encode(self.profileMonitorStatus, forKey: .profileMonitorStatus)}
    if self._protocol != nil {try container.encode(self._protocol, forKey: ._protocol)}
    if self.port != nil {try container.encode(self.port, forKey: .port)}
    if self.path != nil {try container.encode(self.path, forKey: .path)}
    if self.intervalInSeconds != nil {try container.encode(self.intervalInSeconds, forKey: .intervalInSeconds)}
    if self.timeoutInSeconds != nil {try container.encode(self.timeoutInSeconds, forKey: .timeoutInSeconds)}
    if self.toleratedNumberOfFailures != nil {try container.encode(self.toleratedNumberOfFailures, forKey: .toleratedNumberOfFailures)}
  }
}

extension DataFactory {
  public static func createMonitorConfigProtocol() -> MonitorConfigProtocol {
    return MonitorConfigData()
  }
}
