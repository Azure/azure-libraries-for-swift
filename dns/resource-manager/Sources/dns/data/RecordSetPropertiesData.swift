// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
import Foundation
import azureSwiftRuntime
internal struct RecordSetPropertiesData : RecordSetPropertiesProtocol {
    public var metadata: [String:String]?
    public var tTL: Int64?
    public var fqdn: String?
    public var aRecords: [ARecordProtocol?]?
    public var aaaaRecords: [AaaaRecordProtocol?]?
    public var mxRecords: [MxRecordProtocol?]?
    public var nsRecords: [NsRecordProtocol?]?
    public var ptrRecords: [PtrRecordProtocol?]?
    public var srvRecords: [SrvRecordProtocol?]?
    public var txtRecords: [TxtRecordProtocol?]?
    public var cnameRecord: CnameRecordProtocol?
    public var soaRecord: SoaRecordProtocol?
    public var caaRecords: [CaaRecordProtocol?]?

        enum CodingKeys: String, CodingKey {case metadata = "metadata"
        case tTL = "TTL"
        case fqdn = "fqdn"
        case aRecords = "ARecords"
        case aaaaRecords = "AAAARecords"
        case mxRecords = "MXRecords"
        case nsRecords = "NSRecords"
        case ptrRecords = "PTRRecords"
        case srvRecords = "SRVRecords"
        case txtRecords = "TXTRecords"
        case cnameRecord = "CNAMERecord"
        case soaRecord = "SOARecord"
        case caaRecords = "caaRecords"
        }

  public init()  {
  }

  public init(from decoder: Decoder) throws {
    let container = try decoder.container(keyedBy: CodingKeys.self)
      if container.contains(.metadata) {
        self.metadata = try container.decode([String:String]?.self, forKey: .metadata)
    }
    if container.contains(.tTL) {
        self.tTL = try container.decode(Int64?.self, forKey: .tTL)
    }
    if container.contains(.fqdn) {
        self.fqdn = try container.decode(String?.self, forKey: .fqdn)
    }
    if container.contains(.aRecords) {
        self.aRecords = try container.decode([ARecordData?]?.self, forKey: .aRecords)
    }
    if container.contains(.aaaaRecords) {
        self.aaaaRecords = try container.decode([AaaaRecordData?]?.self, forKey: .aaaaRecords)
    }
    if container.contains(.mxRecords) {
        self.mxRecords = try container.decode([MxRecordData?]?.self, forKey: .mxRecords)
    }
    if container.contains(.nsRecords) {
        self.nsRecords = try container.decode([NsRecordData?]?.self, forKey: .nsRecords)
    }
    if container.contains(.ptrRecords) {
        self.ptrRecords = try container.decode([PtrRecordData?]?.self, forKey: .ptrRecords)
    }
    if container.contains(.srvRecords) {
        self.srvRecords = try container.decode([SrvRecordData?]?.self, forKey: .srvRecords)
    }
    if container.contains(.txtRecords) {
        self.txtRecords = try container.decode([TxtRecordData?]?.self, forKey: .txtRecords)
    }
    if container.contains(.cnameRecord) {
        self.cnameRecord = try container.decode(CnameRecordData?.self, forKey: .cnameRecord)
    }
    if container.contains(.soaRecord) {
        self.soaRecord = try container.decode(SoaRecordData?.self, forKey: .soaRecord)
    }
    if container.contains(.caaRecords) {
        self.caaRecords = try container.decode([CaaRecordData?]?.self, forKey: .caaRecords)
    }
    if var pageDecoder = decoder as? PageDecoder  {
      if pageDecoder.isPagedData,
        let nextLinkName = pageDecoder.nextLinkName {
          pageDecoder.nextLink = try UnknownCodingKey.decodeStringForKey(decoder: decoder, keyForDecode: nextLinkName)
      }
    }
  }

  public func encode(to encoder: Encoder) throws {
    var container = encoder.container(keyedBy: CodingKeys.self)
    if self.metadata != nil {try container.encode(self.metadata, forKey: .metadata)}
    if self.tTL != nil {try container.encode(self.tTL, forKey: .tTL)}
    if self.fqdn != nil {try container.encode(self.fqdn, forKey: .fqdn)}
    if self.aRecords != nil {try container.encode(self.aRecords as! [ARecordData?]?, forKey: .aRecords)}
    if self.aaaaRecords != nil {try container.encode(self.aaaaRecords as! [AaaaRecordData?]?, forKey: .aaaaRecords)}
    if self.mxRecords != nil {try container.encode(self.mxRecords as! [MxRecordData?]?, forKey: .mxRecords)}
    if self.nsRecords != nil {try container.encode(self.nsRecords as! [NsRecordData?]?, forKey: .nsRecords)}
    if self.ptrRecords != nil {try container.encode(self.ptrRecords as! [PtrRecordData?]?, forKey: .ptrRecords)}
    if self.srvRecords != nil {try container.encode(self.srvRecords as! [SrvRecordData?]?, forKey: .srvRecords)}
    if self.txtRecords != nil {try container.encode(self.txtRecords as! [TxtRecordData?]?, forKey: .txtRecords)}
    if self.cnameRecord != nil {try container.encode(self.cnameRecord as! CnameRecordData?, forKey: .cnameRecord)}
    if self.soaRecord != nil {try container.encode(self.soaRecord as! SoaRecordData?, forKey: .soaRecord)}
    if self.caaRecords != nil {try container.encode(self.caaRecords as! [CaaRecordData?]?, forKey: .caaRecords)}
  }
}

extension DataFactory {
  public static func createRecordSetPropertiesProtocol() -> RecordSetPropertiesProtocol {
    return RecordSetPropertiesData()
  }
}
