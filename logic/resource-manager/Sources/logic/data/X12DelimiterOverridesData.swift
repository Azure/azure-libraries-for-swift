// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
import Foundation
import azureSwiftRuntime
internal struct X12DelimiterOverridesData : X12DelimiterOverridesProtocol {
    public var protocolVersion: String?
    public var messageId: String?
    public var dataElementSeparator: Int32
    public var componentSeparator: Int32
    public var segmentTerminator: Int32
    public var segmentTerminatorSuffix: SegmentTerminatorSuffixEnum
    public var replaceCharacter: Int32
    public var replaceSeparatorsInPayload: Bool
    public var targetNamespace: String?

        enum CodingKeys: String, CodingKey {case protocolVersion = "protocolVersion"
        case messageId = "messageId"
        case dataElementSeparator = "dataElementSeparator"
        case componentSeparator = "componentSeparator"
        case segmentTerminator = "segmentTerminator"
        case segmentTerminatorSuffix = "segmentTerminatorSuffix"
        case replaceCharacter = "replaceCharacter"
        case replaceSeparatorsInPayload = "replaceSeparatorsInPayload"
        case targetNamespace = "targetNamespace"
        }

  public init(dataElementSeparator: Int32, componentSeparator: Int32, segmentTerminator: Int32, segmentTerminatorSuffix: SegmentTerminatorSuffixEnum, replaceCharacter: Int32, replaceSeparatorsInPayload: Bool)  {
    self.dataElementSeparator = dataElementSeparator
    self.componentSeparator = componentSeparator
    self.segmentTerminator = segmentTerminator
    self.segmentTerminatorSuffix = segmentTerminatorSuffix
    self.replaceCharacter = replaceCharacter
    self.replaceSeparatorsInPayload = replaceSeparatorsInPayload
  }

  public init(from decoder: Decoder) throws {
    let container = try decoder.container(keyedBy: CodingKeys.self)
      if container.contains(.protocolVersion) {
        self.protocolVersion = try container.decode(String?.self, forKey: .protocolVersion)
    }
    if container.contains(.messageId) {
        self.messageId = try container.decode(String?.self, forKey: .messageId)
    }
    self.dataElementSeparator = try container.decode(Int32.self, forKey: .dataElementSeparator)
    self.componentSeparator = try container.decode(Int32.self, forKey: .componentSeparator)
    self.segmentTerminator = try container.decode(Int32.self, forKey: .segmentTerminator)
    self.segmentTerminatorSuffix = try container.decode(SegmentTerminatorSuffixEnum.self, forKey: .segmentTerminatorSuffix)
    self.replaceCharacter = try container.decode(Int32.self, forKey: .replaceCharacter)
    self.replaceSeparatorsInPayload = try container.decode(Bool.self, forKey: .replaceSeparatorsInPayload)
    if container.contains(.targetNamespace) {
        self.targetNamespace = try container.decode(String?.self, forKey: .targetNamespace)
    }
    if var pageDecoder = decoder as? PageDecoder  {
      if pageDecoder.isPagedData,
        let nextLinkName = pageDecoder.nextLinkName {
          pageDecoder.nextLink = try UnknownCodingKey.decodeStringForKey(decoder: decoder, keyForDecode: nextLinkName)
      }
    }
  }

  public func encode(to encoder: Encoder) throws {
    var container = encoder.container(keyedBy: CodingKeys.self)
    if self.protocolVersion != nil {try container.encode(self.protocolVersion, forKey: .protocolVersion)}
    if self.messageId != nil {try container.encode(self.messageId, forKey: .messageId)}
    try container.encode(self.dataElementSeparator, forKey: .dataElementSeparator)
    try container.encode(self.componentSeparator, forKey: .componentSeparator)
    try container.encode(self.segmentTerminator, forKey: .segmentTerminator)
    try container.encode(self.segmentTerminatorSuffix, forKey: .segmentTerminatorSuffix)
    try container.encode(self.replaceCharacter, forKey: .replaceCharacter)
    try container.encode(self.replaceSeparatorsInPayload, forKey: .replaceSeparatorsInPayload)
    if self.targetNamespace != nil {try container.encode(self.targetNamespace, forKey: .targetNamespace)}
  }
}

extension DataFactory {
  public static func createX12DelimiterOverridesProtocol(dataElementSeparator: Int32, componentSeparator: Int32, segmentTerminator: Int32, segmentTerminatorSuffix: SegmentTerminatorSuffixEnum, replaceCharacter: Int32, replaceSeparatorsInPayload: Bool) -> X12DelimiterOverridesProtocol {
    return X12DelimiterOverridesData(dataElementSeparator: dataElementSeparator, componentSeparator: componentSeparator, segmentTerminator: segmentTerminator, segmentTerminatorSuffix: segmentTerminatorSuffix, replaceCharacter: replaceCharacter, replaceSeparatorsInPayload: replaceSeparatorsInPayload)
  }
}
