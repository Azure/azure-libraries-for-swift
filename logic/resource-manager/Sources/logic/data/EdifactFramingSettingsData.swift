// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
import Foundation
import azureSwiftRuntime
internal struct EdifactFramingSettingsData : EdifactFramingSettingsProtocol {
    public var serviceCodeListDirectoryVersion: String?
    public var characterEncoding: String?
    public var protocolVersion: Int32
    public var dataElementSeparator: Int32
    public var componentSeparator: Int32
    public var segmentTerminator: Int32
    public var releaseIndicator: Int32
    public var repetitionSeparator: Int32
    public var characterSet: EdifactCharacterSetEnum
    public var decimalPointIndicator: EdifactDecimalIndicatorEnum
    public var segmentTerminatorSuffix: SegmentTerminatorSuffixEnum

        enum CodingKeys: String, CodingKey {case serviceCodeListDirectoryVersion = "serviceCodeListDirectoryVersion"
        case characterEncoding = "characterEncoding"
        case protocolVersion = "protocolVersion"
        case dataElementSeparator = "dataElementSeparator"
        case componentSeparator = "componentSeparator"
        case segmentTerminator = "segmentTerminator"
        case releaseIndicator = "releaseIndicator"
        case repetitionSeparator = "repetitionSeparator"
        case characterSet = "characterSet"
        case decimalPointIndicator = "decimalPointIndicator"
        case segmentTerminatorSuffix = "segmentTerminatorSuffix"
        }

  public init(protocolVersion: Int32, dataElementSeparator: Int32, componentSeparator: Int32, segmentTerminator: Int32, releaseIndicator: Int32, repetitionSeparator: Int32, characterSet: EdifactCharacterSetEnum, decimalPointIndicator: EdifactDecimalIndicatorEnum, segmentTerminatorSuffix: SegmentTerminatorSuffixEnum)  {
    self.protocolVersion = protocolVersion
    self.dataElementSeparator = dataElementSeparator
    self.componentSeparator = componentSeparator
    self.segmentTerminator = segmentTerminator
    self.releaseIndicator = releaseIndicator
    self.repetitionSeparator = repetitionSeparator
    self.characterSet = characterSet
    self.decimalPointIndicator = decimalPointIndicator
    self.segmentTerminatorSuffix = segmentTerminatorSuffix
  }

  public init(from decoder: Decoder) throws {
    let container = try decoder.container(keyedBy: CodingKeys.self)
      if container.contains(.serviceCodeListDirectoryVersion) {
        self.serviceCodeListDirectoryVersion = try container.decode(String?.self, forKey: .serviceCodeListDirectoryVersion)
    }
    if container.contains(.characterEncoding) {
        self.characterEncoding = try container.decode(String?.self, forKey: .characterEncoding)
    }
    self.protocolVersion = try container.decode(Int32.self, forKey: .protocolVersion)
    self.dataElementSeparator = try container.decode(Int32.self, forKey: .dataElementSeparator)
    self.componentSeparator = try container.decode(Int32.self, forKey: .componentSeparator)
    self.segmentTerminator = try container.decode(Int32.self, forKey: .segmentTerminator)
    self.releaseIndicator = try container.decode(Int32.self, forKey: .releaseIndicator)
    self.repetitionSeparator = try container.decode(Int32.self, forKey: .repetitionSeparator)
    self.characterSet = try container.decode(EdifactCharacterSetEnum.self, forKey: .characterSet)
    self.decimalPointIndicator = try container.decode(EdifactDecimalIndicatorEnum.self, forKey: .decimalPointIndicator)
    self.segmentTerminatorSuffix = try container.decode(SegmentTerminatorSuffixEnum.self, forKey: .segmentTerminatorSuffix)
    if var pageDecoder = decoder as? PageDecoder  {
      if pageDecoder.isPagedData,
        let nextLinkName = pageDecoder.nextLinkName {
          pageDecoder.nextLink = try UnknownCodingKey.decodeStringForKey(decoder: decoder, keyForDecode: nextLinkName)
      }
    }
  }

  public func encode(to encoder: Encoder) throws {
    var container = encoder.container(keyedBy: CodingKeys.self)
    if self.serviceCodeListDirectoryVersion != nil {try container.encode(self.serviceCodeListDirectoryVersion, forKey: .serviceCodeListDirectoryVersion)}
    if self.characterEncoding != nil {try container.encode(self.characterEncoding, forKey: .characterEncoding)}
    try container.encode(self.protocolVersion, forKey: .protocolVersion)
    try container.encode(self.dataElementSeparator, forKey: .dataElementSeparator)
    try container.encode(self.componentSeparator, forKey: .componentSeparator)
    try container.encode(self.segmentTerminator, forKey: .segmentTerminator)
    try container.encode(self.releaseIndicator, forKey: .releaseIndicator)
    try container.encode(self.repetitionSeparator, forKey: .repetitionSeparator)
    try container.encode(self.characterSet, forKey: .characterSet)
    try container.encode(self.decimalPointIndicator, forKey: .decimalPointIndicator)
    try container.encode(self.segmentTerminatorSuffix, forKey: .segmentTerminatorSuffix)
  }
}

extension DataFactory {
  public static func createEdifactFramingSettingsProtocol(protocolVersion: Int32, dataElementSeparator: Int32, componentSeparator: Int32, segmentTerminator: Int32, releaseIndicator: Int32, repetitionSeparator: Int32, characterSet: EdifactCharacterSetEnum, decimalPointIndicator: EdifactDecimalIndicatorEnum, segmentTerminatorSuffix: SegmentTerminatorSuffixEnum) -> EdifactFramingSettingsProtocol {
    return EdifactFramingSettingsData(protocolVersion: protocolVersion, dataElementSeparator: dataElementSeparator, componentSeparator: componentSeparator, segmentTerminator: segmentTerminator, releaseIndicator: releaseIndicator, repetitionSeparator: repetitionSeparator, characterSet: characterSet, decimalPointIndicator: decimalPointIndicator, segmentTerminatorSuffix: segmentTerminatorSuffix)
  }
}
