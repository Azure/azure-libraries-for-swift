// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
import Foundation
import azureSwiftRuntime
internal struct EdifactProtocolSettingsData : EdifactProtocolSettingsProtocol {
    public var validationSettings: EdifactValidationSettingsProtocol
    public var framingSettings: EdifactFramingSettingsProtocol
    public var envelopeSettings: EdifactEnvelopeSettingsProtocol
    public var acknowledgementSettings: EdifactAcknowledgementSettingsProtocol
    public var messageFilter: EdifactMessageFilterProtocol
    public var processingSettings: EdifactProcessingSettingsProtocol
    public var envelopeOverrides: [EdifactEnvelopeOverrideProtocol?]?
    public var messageFilterList: [EdifactMessageIdentifierProtocol?]?
    public var schemaReferences: [EdifactSchemaReferenceProtocol]
    public var validationOverrides: [EdifactValidationOverrideProtocol?]?
    public var edifactDelimiterOverrides: [EdifactDelimiterOverrideProtocol?]?

        enum CodingKeys: String, CodingKey {case validationSettings = "validationSettings"
        case framingSettings = "framingSettings"
        case envelopeSettings = "envelopeSettings"
        case acknowledgementSettings = "acknowledgementSettings"
        case messageFilter = "messageFilter"
        case processingSettings = "processingSettings"
        case envelopeOverrides = "envelopeOverrides"
        case messageFilterList = "messageFilterList"
        case schemaReferences = "schemaReferences"
        case validationOverrides = "validationOverrides"
        case edifactDelimiterOverrides = "edifactDelimiterOverrides"
        }

  public init(validationSettings: EdifactValidationSettingsProtocol, framingSettings: EdifactFramingSettingsProtocol, envelopeSettings: EdifactEnvelopeSettingsProtocol, acknowledgementSettings: EdifactAcknowledgementSettingsProtocol, messageFilter: EdifactMessageFilterProtocol, processingSettings: EdifactProcessingSettingsProtocol, schemaReferences: [EdifactSchemaReferenceProtocol])  {
    self.validationSettings = validationSettings
    self.framingSettings = framingSettings
    self.envelopeSettings = envelopeSettings
    self.acknowledgementSettings = acknowledgementSettings
    self.messageFilter = messageFilter
    self.processingSettings = processingSettings
    self.schemaReferences = schemaReferences
  }

  public init(from decoder: Decoder) throws {
    let container = try decoder.container(keyedBy: CodingKeys.self)
      self.validationSettings = try container.decode(EdifactValidationSettingsData.self, forKey: .validationSettings)
    self.framingSettings = try container.decode(EdifactFramingSettingsData.self, forKey: .framingSettings)
    self.envelopeSettings = try container.decode(EdifactEnvelopeSettingsData.self, forKey: .envelopeSettings)
    self.acknowledgementSettings = try container.decode(EdifactAcknowledgementSettingsData.self, forKey: .acknowledgementSettings)
    self.messageFilter = try container.decode(EdifactMessageFilterData.self, forKey: .messageFilter)
    self.processingSettings = try container.decode(EdifactProcessingSettingsData.self, forKey: .processingSettings)
    if container.contains(.envelopeOverrides) {
        self.envelopeOverrides = try container.decode([EdifactEnvelopeOverrideData?]?.self, forKey: .envelopeOverrides)
    }
    if container.contains(.messageFilterList) {
        self.messageFilterList = try container.decode([EdifactMessageIdentifierData?]?.self, forKey: .messageFilterList)
    }
    self.schemaReferences = try container.decode([EdifactSchemaReferenceData].self, forKey: .schemaReferences)
    if container.contains(.validationOverrides) {
        self.validationOverrides = try container.decode([EdifactValidationOverrideData?]?.self, forKey: .validationOverrides)
    }
    if container.contains(.edifactDelimiterOverrides) {
        self.edifactDelimiterOverrides = try container.decode([EdifactDelimiterOverrideData?]?.self, forKey: .edifactDelimiterOverrides)
    }
    if var pageDecoder = decoder as? PageDecoder  {
      if pageDecoder.isPagedData,
        let nextLinkName = pageDecoder.nextLinkName {
          pageDecoder.nextLink = try UnknownCodingKey.decodeStringForKey(decoder: decoder, keyForDecode: nextLinkName)
      }
    }
  }

  public func encode(to encoder: Encoder) throws {
    var container = encoder.container(keyedBy: CodingKeys.self)
    try container.encode(self.validationSettings as! EdifactValidationSettingsData, forKey: .validationSettings)
    try container.encode(self.framingSettings as! EdifactFramingSettingsData, forKey: .framingSettings)
    try container.encode(self.envelopeSettings as! EdifactEnvelopeSettingsData, forKey: .envelopeSettings)
    try container.encode(self.acknowledgementSettings as! EdifactAcknowledgementSettingsData, forKey: .acknowledgementSettings)
    try container.encode(self.messageFilter as! EdifactMessageFilterData, forKey: .messageFilter)
    try container.encode(self.processingSettings as! EdifactProcessingSettingsData, forKey: .processingSettings)
    if self.envelopeOverrides != nil {try container.encode(self.envelopeOverrides as! [EdifactEnvelopeOverrideData?]?, forKey: .envelopeOverrides)}
    if self.messageFilterList != nil {try container.encode(self.messageFilterList as! [EdifactMessageIdentifierData?]?, forKey: .messageFilterList)}
    try container.encode(self.schemaReferences as! [EdifactSchemaReferenceData], forKey: .schemaReferences)
    if self.validationOverrides != nil {try container.encode(self.validationOverrides as! [EdifactValidationOverrideData?]?, forKey: .validationOverrides)}
    if self.edifactDelimiterOverrides != nil {try container.encode(self.edifactDelimiterOverrides as! [EdifactDelimiterOverrideData?]?, forKey: .edifactDelimiterOverrides)}
  }
}

extension DataFactory {
  public static func createEdifactProtocolSettingsProtocol(validationSettings: EdifactValidationSettingsProtocol, framingSettings: EdifactFramingSettingsProtocol, envelopeSettings: EdifactEnvelopeSettingsProtocol, acknowledgementSettings: EdifactAcknowledgementSettingsProtocol, messageFilter: EdifactMessageFilterProtocol, processingSettings: EdifactProcessingSettingsProtocol, schemaReferences: [EdifactSchemaReferenceProtocol]) -> EdifactProtocolSettingsProtocol {
    return EdifactProtocolSettingsData(validationSettings: validationSettings, framingSettings: framingSettings, envelopeSettings: envelopeSettings, acknowledgementSettings: acknowledgementSettings, messageFilter: messageFilter, processingSettings: processingSettings, schemaReferences: schemaReferences)
  }
}
