// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
import Foundation
import azureSwiftRuntime
internal struct VirtualNetworkGatewayConnectionPropertiesFormatData : VirtualNetworkGatewayConnectionPropertiesFormatProtocol {
    public var authorizationKey: String?
    public var virtualNetworkGateway1: VirtualNetworkGatewayProtocol
    public var virtualNetworkGateway2: VirtualNetworkGatewayProtocol?
    public var localNetworkGateway2: LocalNetworkGatewayProtocol?
    public var connectionType: VirtualNetworkGatewayConnectionTypeEnum
    public var routingWeight: Int32?
    public var sharedKey: String?
    public var connectionStatus: VirtualNetworkGatewayConnectionStatusEnum?
    public var tunnelConnectionStatus: [TunnelConnectionHealthProtocol?]?
    public var egressBytesTransferred: Int64?
    public var ingressBytesTransferred: Int64?
    public var peer: SubResourceProtocol?
    public var enableBgp: Bool?
    public var usePolicyBasedTrafficSelectors: Bool?
    public var ipsecPolicies: [IpsecPolicyProtocol?]?
    public var resourceGuid: String?
    public var provisioningState: String?

        enum CodingKeys: String, CodingKey {case authorizationKey = "authorizationKey"
        case virtualNetworkGateway1 = "virtualNetworkGateway1"
        case virtualNetworkGateway2 = "virtualNetworkGateway2"
        case localNetworkGateway2 = "localNetworkGateway2"
        case connectionType = "connectionType"
        case routingWeight = "routingWeight"
        case sharedKey = "sharedKey"
        case connectionStatus = "connectionStatus"
        case tunnelConnectionStatus = "tunnelConnectionStatus"
        case egressBytesTransferred = "egressBytesTransferred"
        case ingressBytesTransferred = "ingressBytesTransferred"
        case peer = "peer"
        case enableBgp = "enableBgp"
        case usePolicyBasedTrafficSelectors = "usePolicyBasedTrafficSelectors"
        case ipsecPolicies = "ipsecPolicies"
        case resourceGuid = "resourceGuid"
        case provisioningState = "provisioningState"
        }

  public init(virtualNetworkGateway1: VirtualNetworkGatewayProtocol, connectionType: VirtualNetworkGatewayConnectionTypeEnum)  {
    self.virtualNetworkGateway1 = virtualNetworkGateway1
    self.connectionType = connectionType
  }

  public init(from decoder: Decoder) throws {
    let container = try decoder.container(keyedBy: CodingKeys.self)
      if container.contains(.authorizationKey) {
        self.authorizationKey = try container.decode(String?.self, forKey: .authorizationKey)
    }
    self.virtualNetworkGateway1 = try container.decode(VirtualNetworkGatewayData.self, forKey: .virtualNetworkGateway1)
    if container.contains(.virtualNetworkGateway2) {
        self.virtualNetworkGateway2 = try container.decode(VirtualNetworkGatewayData?.self, forKey: .virtualNetworkGateway2)
    }
    if container.contains(.localNetworkGateway2) {
        self.localNetworkGateway2 = try container.decode(LocalNetworkGatewayData?.self, forKey: .localNetworkGateway2)
    }
    self.connectionType = try container.decode(VirtualNetworkGatewayConnectionTypeEnum.self, forKey: .connectionType)
    if container.contains(.routingWeight) {
        self.routingWeight = try container.decode(Int32?.self, forKey: .routingWeight)
    }
    if container.contains(.sharedKey) {
        self.sharedKey = try container.decode(String?.self, forKey: .sharedKey)
    }
    if container.contains(.connectionStatus) {
        self.connectionStatus = try container.decode(VirtualNetworkGatewayConnectionStatusEnum?.self, forKey: .connectionStatus)
    }
    if container.contains(.tunnelConnectionStatus) {
        self.tunnelConnectionStatus = try container.decode([TunnelConnectionHealthData?]?.self, forKey: .tunnelConnectionStatus)
    }
    if container.contains(.egressBytesTransferred) {
        self.egressBytesTransferred = try container.decode(Int64?.self, forKey: .egressBytesTransferred)
    }
    if container.contains(.ingressBytesTransferred) {
        self.ingressBytesTransferred = try container.decode(Int64?.self, forKey: .ingressBytesTransferred)
    }
    if container.contains(.peer) {
        self.peer = try container.decode(SubResourceData?.self, forKey: .peer)
    }
    if container.contains(.enableBgp) {
        self.enableBgp = try container.decode(Bool?.self, forKey: .enableBgp)
    }
    if container.contains(.usePolicyBasedTrafficSelectors) {
        self.usePolicyBasedTrafficSelectors = try container.decode(Bool?.self, forKey: .usePolicyBasedTrafficSelectors)
    }
    if container.contains(.ipsecPolicies) {
        self.ipsecPolicies = try container.decode([IpsecPolicyData?]?.self, forKey: .ipsecPolicies)
    }
    if container.contains(.resourceGuid) {
        self.resourceGuid = try container.decode(String?.self, forKey: .resourceGuid)
    }
    if container.contains(.provisioningState) {
        self.provisioningState = try container.decode(String?.self, forKey: .provisioningState)
    }
    if var pageDecoder = decoder as? PageDecoder  {
      if pageDecoder.isPagedData,
        let nextLinkName = pageDecoder.nextLinkName {
          pageDecoder.nextLink = try UnknownCodingKey.decodeStringForKey(decoder: decoder, keyForDecode: nextLinkName)
      }
    }
  }

  public func encode(to encoder: Encoder) throws {
    var container = encoder.container(keyedBy: CodingKeys.self)
    if self.authorizationKey != nil {try container.encode(self.authorizationKey, forKey: .authorizationKey)}
    try container.encode(self.virtualNetworkGateway1 as! VirtualNetworkGatewayData, forKey: .virtualNetworkGateway1)
    if self.virtualNetworkGateway2 != nil {try container.encode(self.virtualNetworkGateway2 as! VirtualNetworkGatewayData?, forKey: .virtualNetworkGateway2)}
    if self.localNetworkGateway2 != nil {try container.encode(self.localNetworkGateway2 as! LocalNetworkGatewayData?, forKey: .localNetworkGateway2)}
    try container.encode(self.connectionType, forKey: .connectionType)
    if self.routingWeight != nil {try container.encode(self.routingWeight, forKey: .routingWeight)}
    if self.sharedKey != nil {try container.encode(self.sharedKey, forKey: .sharedKey)}
    if self.connectionStatus != nil {try container.encode(self.connectionStatus, forKey: .connectionStatus)}
    if self.tunnelConnectionStatus != nil {try container.encode(self.tunnelConnectionStatus as! [TunnelConnectionHealthData?]?, forKey: .tunnelConnectionStatus)}
    if self.egressBytesTransferred != nil {try container.encode(self.egressBytesTransferred, forKey: .egressBytesTransferred)}
    if self.ingressBytesTransferred != nil {try container.encode(self.ingressBytesTransferred, forKey: .ingressBytesTransferred)}
    if self.peer != nil {try container.encode(self.peer as! SubResourceData?, forKey: .peer)}
    if self.enableBgp != nil {try container.encode(self.enableBgp, forKey: .enableBgp)}
    if self.usePolicyBasedTrafficSelectors != nil {try container.encode(self.usePolicyBasedTrafficSelectors, forKey: .usePolicyBasedTrafficSelectors)}
    if self.ipsecPolicies != nil {try container.encode(self.ipsecPolicies as! [IpsecPolicyData?]?, forKey: .ipsecPolicies)}
    if self.resourceGuid != nil {try container.encode(self.resourceGuid, forKey: .resourceGuid)}
    if self.provisioningState != nil {try container.encode(self.provisioningState, forKey: .provisioningState)}
  }
}

extension DataFactory {
  public static func createVirtualNetworkGatewayConnectionPropertiesFormatProtocol(virtualNetworkGateway1: VirtualNetworkGatewayProtocol, connectionType: VirtualNetworkGatewayConnectionTypeEnum) -> VirtualNetworkGatewayConnectionPropertiesFormatProtocol {
    return VirtualNetworkGatewayConnectionPropertiesFormatData(virtualNetworkGateway1: virtualNetworkGateway1, connectionType: connectionType)
  }
}
