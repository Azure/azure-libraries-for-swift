// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
import Foundation
import azureSwiftRuntime
internal struct SecurityRulePropertiesFormatData : SecurityRulePropertiesFormatProtocol {
    public var description: String?
    public var _protocol: SecurityRuleProtocolEnum
    public var sourcePortRange: String?
    public var destinationPortRange: String?
    public var sourceAddressPrefix: String?
    public var sourceAddressPrefixes: [String]?
    public var sourceApplicationSecurityGroups: [ApplicationSecurityGroupProtocol?]?
    public var destinationAddressPrefix: String?
    public var destinationAddressPrefixes: [String]?
    public var destinationApplicationSecurityGroups: [ApplicationSecurityGroupProtocol?]?
    public var sourcePortRanges: [String]?
    public var destinationPortRanges: [String]?
    public var access: SecurityRuleAccessEnum
    public var priority: Int32?
    public var direction: SecurityRuleDirectionEnum
    public var provisioningState: String?

        enum CodingKeys: String, CodingKey {case description = "description"
        case _protocol = "protocol"
        case sourcePortRange = "sourcePortRange"
        case destinationPortRange = "destinationPortRange"
        case sourceAddressPrefix = "sourceAddressPrefix"
        case sourceAddressPrefixes = "sourceAddressPrefixes"
        case sourceApplicationSecurityGroups = "sourceApplicationSecurityGroups"
        case destinationAddressPrefix = "destinationAddressPrefix"
        case destinationAddressPrefixes = "destinationAddressPrefixes"
        case destinationApplicationSecurityGroups = "destinationApplicationSecurityGroups"
        case sourcePortRanges = "sourcePortRanges"
        case destinationPortRanges = "destinationPortRanges"
        case access = "access"
        case priority = "priority"
        case direction = "direction"
        case provisioningState = "provisioningState"
        }

  public init(_protocol: SecurityRuleProtocolEnum, access: SecurityRuleAccessEnum, direction: SecurityRuleDirectionEnum)  {
    self._protocol = _protocol
    self.access = access
    self.direction = direction
  }

  public init(from decoder: Decoder) throws {
    let container = try decoder.container(keyedBy: CodingKeys.self)
      if container.contains(.description) {
        self.description = try container.decode(String?.self, forKey: .description)
    }
    self._protocol = try container.decode(SecurityRuleProtocolEnum.self, forKey: ._protocol)
    if container.contains(.sourcePortRange) {
        self.sourcePortRange = try container.decode(String?.self, forKey: .sourcePortRange)
    }
    if container.contains(.destinationPortRange) {
        self.destinationPortRange = try container.decode(String?.self, forKey: .destinationPortRange)
    }
    if container.contains(.sourceAddressPrefix) {
        self.sourceAddressPrefix = try container.decode(String?.self, forKey: .sourceAddressPrefix)
    }
    if container.contains(.sourceAddressPrefixes) {
        self.sourceAddressPrefixes = try container.decode([String]?.self, forKey: .sourceAddressPrefixes)
    }
    if container.contains(.sourceApplicationSecurityGroups) {
        self.sourceApplicationSecurityGroups = try container.decode([ApplicationSecurityGroupData?]?.self, forKey: .sourceApplicationSecurityGroups)
    }
    if container.contains(.destinationAddressPrefix) {
        self.destinationAddressPrefix = try container.decode(String?.self, forKey: .destinationAddressPrefix)
    }
    if container.contains(.destinationAddressPrefixes) {
        self.destinationAddressPrefixes = try container.decode([String]?.self, forKey: .destinationAddressPrefixes)
    }
    if container.contains(.destinationApplicationSecurityGroups) {
        self.destinationApplicationSecurityGroups = try container.decode([ApplicationSecurityGroupData?]?.self, forKey: .destinationApplicationSecurityGroups)
    }
    if container.contains(.sourcePortRanges) {
        self.sourcePortRanges = try container.decode([String]?.self, forKey: .sourcePortRanges)
    }
    if container.contains(.destinationPortRanges) {
        self.destinationPortRanges = try container.decode([String]?.self, forKey: .destinationPortRanges)
    }
    self.access = try container.decode(SecurityRuleAccessEnum.self, forKey: .access)
    if container.contains(.priority) {
        self.priority = try container.decode(Int32?.self, forKey: .priority)
    }
    self.direction = try container.decode(SecurityRuleDirectionEnum.self, forKey: .direction)
    if container.contains(.provisioningState) {
        self.provisioningState = try container.decode(String?.self, forKey: .provisioningState)
    }
    if var pageDecoder = decoder as? PageDecoder  {
      if pageDecoder.isPagedData,
        let nextLinkName = pageDecoder.nextLinkName {
          pageDecoder.nextLink = try UnknownCodingKey.decodeStringForKey(decoder: decoder, keyForDecode: nextLinkName)
      }
    }
  }

  public func encode(to encoder: Encoder) throws {
    var container = encoder.container(keyedBy: CodingKeys.self)
    if self.description != nil {try container.encode(self.description, forKey: .description)}
    try container.encode(self._protocol, forKey: ._protocol)
    if self.sourcePortRange != nil {try container.encode(self.sourcePortRange, forKey: .sourcePortRange)}
    if self.destinationPortRange != nil {try container.encode(self.destinationPortRange, forKey: .destinationPortRange)}
    if self.sourceAddressPrefix != nil {try container.encode(self.sourceAddressPrefix, forKey: .sourceAddressPrefix)}
    if self.sourceAddressPrefixes != nil {try container.encode(self.sourceAddressPrefixes as! [String]?, forKey: .sourceAddressPrefixes)}
    if self.sourceApplicationSecurityGroups != nil {try container.encode(self.sourceApplicationSecurityGroups as! [ApplicationSecurityGroupData?]?, forKey: .sourceApplicationSecurityGroups)}
    if self.destinationAddressPrefix != nil {try container.encode(self.destinationAddressPrefix, forKey: .destinationAddressPrefix)}
    if self.destinationAddressPrefixes != nil {try container.encode(self.destinationAddressPrefixes as! [String]?, forKey: .destinationAddressPrefixes)}
    if self.destinationApplicationSecurityGroups != nil {try container.encode(self.destinationApplicationSecurityGroups as! [ApplicationSecurityGroupData?]?, forKey: .destinationApplicationSecurityGroups)}
    if self.sourcePortRanges != nil {try container.encode(self.sourcePortRanges as! [String]?, forKey: .sourcePortRanges)}
    if self.destinationPortRanges != nil {try container.encode(self.destinationPortRanges as! [String]?, forKey: .destinationPortRanges)}
    try container.encode(self.access, forKey: .access)
    if self.priority != nil {try container.encode(self.priority, forKey: .priority)}
    try container.encode(self.direction, forKey: .direction)
    if self.provisioningState != nil {try container.encode(self.provisioningState, forKey: .provisioningState)}
  }
}

extension DataFactory {
  public static func createSecurityRulePropertiesFormatProtocol(_protocol: SecurityRuleProtocolEnum, access: SecurityRuleAccessEnum, direction: SecurityRuleDirectionEnum) -> SecurityRulePropertiesFormatProtocol {
    return SecurityRulePropertiesFormatData(_protocol: _protocol, access: access, direction: direction)
  }
}
