// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
import Foundation
import azureSwiftRuntime
internal struct VpnClientConfigurationData : VpnClientConfigurationProtocol {
    public var vpnClientAddressPool: AddressSpaceProtocol?
    public var vpnClientRootCertificates: [VpnClientRootCertificateProtocol?]?
    public var vpnClientRevokedCertificates: [VpnClientRevokedCertificateProtocol?]?
    public var vpnClientProtocols: [VpnClientProtocolEnum?]?
    public var radiusServerAddress: String?
    public var radiusServerSecret: String?

        enum CodingKeys: String, CodingKey {case vpnClientAddressPool = "vpnClientAddressPool"
        case vpnClientRootCertificates = "vpnClientRootCertificates"
        case vpnClientRevokedCertificates = "vpnClientRevokedCertificates"
        case vpnClientProtocols = "vpnClientProtocols"
        case radiusServerAddress = "radiusServerAddress"
        case radiusServerSecret = "radiusServerSecret"
        }

  public init()  {
  }

  public init(from decoder: Decoder) throws {
    let container = try decoder.container(keyedBy: CodingKeys.self)
      if container.contains(.vpnClientAddressPool) {
        self.vpnClientAddressPool = try container.decode(AddressSpaceData?.self, forKey: .vpnClientAddressPool)
    }
    if container.contains(.vpnClientRootCertificates) {
        self.vpnClientRootCertificates = try container.decode([VpnClientRootCertificateData?]?.self, forKey: .vpnClientRootCertificates)
    }
    if container.contains(.vpnClientRevokedCertificates) {
        self.vpnClientRevokedCertificates = try container.decode([VpnClientRevokedCertificateData?]?.self, forKey: .vpnClientRevokedCertificates)
    }
    if container.contains(.vpnClientProtocols) {
        self.vpnClientProtocols = try container.decode([VpnClientProtocolEnum?]?.self, forKey: .vpnClientProtocols)
    }
    if container.contains(.radiusServerAddress) {
        self.radiusServerAddress = try container.decode(String?.self, forKey: .radiusServerAddress)
    }
    if container.contains(.radiusServerSecret) {
        self.radiusServerSecret = try container.decode(String?.self, forKey: .radiusServerSecret)
    }
    if var pageDecoder = decoder as? PageDecoder  {
      if pageDecoder.isPagedData,
        let nextLinkName = pageDecoder.nextLinkName {
          pageDecoder.nextLink = try UnknownCodingKey.decodeStringForKey(decoder: decoder, keyForDecode: nextLinkName)
      }
    }
  }

  public func encode(to encoder: Encoder) throws {
    var container = encoder.container(keyedBy: CodingKeys.self)
    if self.vpnClientAddressPool != nil {try container.encode(self.vpnClientAddressPool as! AddressSpaceData?, forKey: .vpnClientAddressPool)}
    if self.vpnClientRootCertificates != nil {try container.encode(self.vpnClientRootCertificates as! [VpnClientRootCertificateData?]?, forKey: .vpnClientRootCertificates)}
    if self.vpnClientRevokedCertificates != nil {try container.encode(self.vpnClientRevokedCertificates as! [VpnClientRevokedCertificateData?]?, forKey: .vpnClientRevokedCertificates)}
    if self.vpnClientProtocols != nil {try container.encode(self.vpnClientProtocols as! [VpnClientProtocolEnum?]?, forKey: .vpnClientProtocols)}
    if self.radiusServerAddress != nil {try container.encode(self.radiusServerAddress, forKey: .radiusServerAddress)}
    if self.radiusServerSecret != nil {try container.encode(self.radiusServerSecret, forKey: .radiusServerSecret)}
  }
}

extension DataFactory {
  public static func createVpnClientConfigurationProtocol() -> VpnClientConfigurationProtocol {
    return VpnClientConfigurationData()
  }
}
