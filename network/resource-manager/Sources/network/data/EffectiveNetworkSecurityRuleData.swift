// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
import Foundation
import azureSwiftRuntime
internal struct EffectiveNetworkSecurityRuleData : EffectiveNetworkSecurityRuleProtocol {
    public var name: String?
    public var _protocol: EffectiveSecurityRuleProtocolEnum?
    public var sourcePortRange: String?
    public var destinationPortRange: String?
    public var sourcePortRanges: [String]?
    public var destinationPortRanges: [String]?
    public var sourceAddressPrefix: String?
    public var destinationAddressPrefix: String?
    public var sourceAddressPrefixes: [String]?
    public var destinationAddressPrefixes: [String]?
    public var expandedSourceAddressPrefix: [String]?
    public var expandedDestinationAddressPrefix: [String]?
    public var access: SecurityRuleAccessEnum?
    public var priority: Int32?
    public var direction: SecurityRuleDirectionEnum?

        enum CodingKeys: String, CodingKey {case name = "name"
        case _protocol = "protocol"
        case sourcePortRange = "sourcePortRange"
        case destinationPortRange = "destinationPortRange"
        case sourcePortRanges = "sourcePortRanges"
        case destinationPortRanges = "destinationPortRanges"
        case sourceAddressPrefix = "sourceAddressPrefix"
        case destinationAddressPrefix = "destinationAddressPrefix"
        case sourceAddressPrefixes = "sourceAddressPrefixes"
        case destinationAddressPrefixes = "destinationAddressPrefixes"
        case expandedSourceAddressPrefix = "expandedSourceAddressPrefix"
        case expandedDestinationAddressPrefix = "expandedDestinationAddressPrefix"
        case access = "access"
        case priority = "priority"
        case direction = "direction"
        }

  public init()  {
  }

  public init(from decoder: Decoder) throws {
    let container = try decoder.container(keyedBy: CodingKeys.self)
      if container.contains(.name) {
        self.name = try container.decode(String?.self, forKey: .name)
    }
    if container.contains(._protocol) {
        self._protocol = try container.decode(EffectiveSecurityRuleProtocolEnum?.self, forKey: ._protocol)
    }
    if container.contains(.sourcePortRange) {
        self.sourcePortRange = try container.decode(String?.self, forKey: .sourcePortRange)
    }
    if container.contains(.destinationPortRange) {
        self.destinationPortRange = try container.decode(String?.self, forKey: .destinationPortRange)
    }
    if container.contains(.sourcePortRanges) {
        self.sourcePortRanges = try container.decode([String]?.self, forKey: .sourcePortRanges)
    }
    if container.contains(.destinationPortRanges) {
        self.destinationPortRanges = try container.decode([String]?.self, forKey: .destinationPortRanges)
    }
    if container.contains(.sourceAddressPrefix) {
        self.sourceAddressPrefix = try container.decode(String?.self, forKey: .sourceAddressPrefix)
    }
    if container.contains(.destinationAddressPrefix) {
        self.destinationAddressPrefix = try container.decode(String?.self, forKey: .destinationAddressPrefix)
    }
    if container.contains(.sourceAddressPrefixes) {
        self.sourceAddressPrefixes = try container.decode([String]?.self, forKey: .sourceAddressPrefixes)
    }
    if container.contains(.destinationAddressPrefixes) {
        self.destinationAddressPrefixes = try container.decode([String]?.self, forKey: .destinationAddressPrefixes)
    }
    if container.contains(.expandedSourceAddressPrefix) {
        self.expandedSourceAddressPrefix = try container.decode([String]?.self, forKey: .expandedSourceAddressPrefix)
    }
    if container.contains(.expandedDestinationAddressPrefix) {
        self.expandedDestinationAddressPrefix = try container.decode([String]?.self, forKey: .expandedDestinationAddressPrefix)
    }
    if container.contains(.access) {
        self.access = try container.decode(SecurityRuleAccessEnum?.self, forKey: .access)
    }
    if container.contains(.priority) {
        self.priority = try container.decode(Int32?.self, forKey: .priority)
    }
    if container.contains(.direction) {
        self.direction = try container.decode(SecurityRuleDirectionEnum?.self, forKey: .direction)
    }
    if var pageDecoder = decoder as? PageDecoder  {
      if pageDecoder.isPagedData,
        let nextLinkName = pageDecoder.nextLinkName {
          pageDecoder.nextLink = try UnknownCodingKey.decodeStringForKey(decoder: decoder, keyForDecode: nextLinkName)
      }
    }
  }

  public func encode(to encoder: Encoder) throws {
    var container = encoder.container(keyedBy: CodingKeys.self)
    if self.name != nil {try container.encode(self.name, forKey: .name)}
    if self._protocol != nil {try container.encode(self._protocol, forKey: ._protocol)}
    if self.sourcePortRange != nil {try container.encode(self.sourcePortRange, forKey: .sourcePortRange)}
    if self.destinationPortRange != nil {try container.encode(self.destinationPortRange, forKey: .destinationPortRange)}
    if self.sourcePortRanges != nil {try container.encode(self.sourcePortRanges as! [String]?, forKey: .sourcePortRanges)}
    if self.destinationPortRanges != nil {try container.encode(self.destinationPortRanges as! [String]?, forKey: .destinationPortRanges)}
    if self.sourceAddressPrefix != nil {try container.encode(self.sourceAddressPrefix, forKey: .sourceAddressPrefix)}
    if self.destinationAddressPrefix != nil {try container.encode(self.destinationAddressPrefix, forKey: .destinationAddressPrefix)}
    if self.sourceAddressPrefixes != nil {try container.encode(self.sourceAddressPrefixes as! [String]?, forKey: .sourceAddressPrefixes)}
    if self.destinationAddressPrefixes != nil {try container.encode(self.destinationAddressPrefixes as! [String]?, forKey: .destinationAddressPrefixes)}
    if self.expandedSourceAddressPrefix != nil {try container.encode(self.expandedSourceAddressPrefix as! [String]?, forKey: .expandedSourceAddressPrefix)}
    if self.expandedDestinationAddressPrefix != nil {try container.encode(self.expandedDestinationAddressPrefix as! [String]?, forKey: .expandedDestinationAddressPrefix)}
    if self.access != nil {try container.encode(self.access, forKey: .access)}
    if self.priority != nil {try container.encode(self.priority, forKey: .priority)}
    if self.direction != nil {try container.encode(self.direction, forKey: .direction)}
  }
}

extension DataFactory {
  public static func createEffectiveNetworkSecurityRuleProtocol() -> EffectiveNetworkSecurityRuleProtocol {
    return EffectiveNetworkSecurityRuleData()
  }
}
