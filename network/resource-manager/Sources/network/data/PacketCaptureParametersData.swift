// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
import Foundation
import azureSwiftRuntime
internal struct PacketCaptureParametersData : PacketCaptureParametersProtocol {
    public var target: String
    public var bytesToCapturePerPacket: Int32?
    public var totalBytesPerSession: Int32?
    public var timeLimitInSeconds: Int32?
    public var storageLocation: PacketCaptureStorageLocationProtocol
    public var filters: [PacketCaptureFilterProtocol?]?

        enum CodingKeys: String, CodingKey {case target = "target"
        case bytesToCapturePerPacket = "bytesToCapturePerPacket"
        case totalBytesPerSession = "totalBytesPerSession"
        case timeLimitInSeconds = "timeLimitInSeconds"
        case storageLocation = "storageLocation"
        case filters = "filters"
        }

  public init(target: String, storageLocation: PacketCaptureStorageLocationProtocol)  {
    self.target = target
    self.storageLocation = storageLocation
  }

  public init(from decoder: Decoder) throws {
    let container = try decoder.container(keyedBy: CodingKeys.self)
      self.target = try container.decode(String.self, forKey: .target)
    if container.contains(.bytesToCapturePerPacket) {
        self.bytesToCapturePerPacket = try container.decode(Int32?.self, forKey: .bytesToCapturePerPacket)
    }
    if container.contains(.totalBytesPerSession) {
        self.totalBytesPerSession = try container.decode(Int32?.self, forKey: .totalBytesPerSession)
    }
    if container.contains(.timeLimitInSeconds) {
        self.timeLimitInSeconds = try container.decode(Int32?.self, forKey: .timeLimitInSeconds)
    }
    self.storageLocation = try container.decode(PacketCaptureStorageLocationData.self, forKey: .storageLocation)
    if container.contains(.filters) {
        self.filters = try container.decode([PacketCaptureFilterData?]?.self, forKey: .filters)
    }
    if var pageDecoder = decoder as? PageDecoder  {
      if pageDecoder.isPagedData,
        let nextLinkName = pageDecoder.nextLinkName {
          pageDecoder.nextLink = try UnknownCodingKey.decodeStringForKey(decoder: decoder, keyForDecode: nextLinkName)
      }
    }
  }

  public func encode(to encoder: Encoder) throws {
    var container = encoder.container(keyedBy: CodingKeys.self)
    try container.encode(self.target, forKey: .target)
    if self.bytesToCapturePerPacket != nil {try container.encode(self.bytesToCapturePerPacket, forKey: .bytesToCapturePerPacket)}
    if self.totalBytesPerSession != nil {try container.encode(self.totalBytesPerSession, forKey: .totalBytesPerSession)}
    if self.timeLimitInSeconds != nil {try container.encode(self.timeLimitInSeconds, forKey: .timeLimitInSeconds)}
    try container.encode(self.storageLocation as! PacketCaptureStorageLocationData, forKey: .storageLocation)
    if self.filters != nil {try container.encode(self.filters as! [PacketCaptureFilterData?]?, forKey: .filters)}
  }
}

extension DataFactory {
  public static func createPacketCaptureParametersProtocol(target: String, storageLocation: PacketCaptureStorageLocationProtocol) -> PacketCaptureParametersProtocol {
    return PacketCaptureParametersData(target: target, storageLocation: storageLocation)
  }
}
