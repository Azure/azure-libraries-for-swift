// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
import Foundation
import azureSwiftRuntime
internal struct ExpressRouteCircuitPropertiesFormatData : ExpressRouteCircuitPropertiesFormatProtocol {
    public var allowClassicOperations: Bool?
    public var circuitProvisioningState: String?
    public var serviceProviderProvisioningState: ServiceProviderProvisioningStateEnum?
    public var authorizations: [ExpressRouteCircuitAuthorizationProtocol?]?
    public var peerings: [ExpressRouteCircuitPeeringProtocol?]?
    public var serviceKey: String?
    public var serviceProviderNotes: String?
    public var serviceProviderProperties: ExpressRouteCircuitServiceProviderPropertiesProtocol?
    public var provisioningState: String?
    public var gatewayManagerEtag: String?

        enum CodingKeys: String, CodingKey {case allowClassicOperations = "allowClassicOperations"
        case circuitProvisioningState = "circuitProvisioningState"
        case serviceProviderProvisioningState = "serviceProviderProvisioningState"
        case authorizations = "authorizations"
        case peerings = "peerings"
        case serviceKey = "serviceKey"
        case serviceProviderNotes = "serviceProviderNotes"
        case serviceProviderProperties = "serviceProviderProperties"
        case provisioningState = "provisioningState"
        case gatewayManagerEtag = "gatewayManagerEtag"
        }

  public init()  {
  }

  public init(from decoder: Decoder) throws {
    let container = try decoder.container(keyedBy: CodingKeys.self)
      if container.contains(.allowClassicOperations) {
        self.allowClassicOperations = try container.decode(Bool?.self, forKey: .allowClassicOperations)
    }
    if container.contains(.circuitProvisioningState) {
        self.circuitProvisioningState = try container.decode(String?.self, forKey: .circuitProvisioningState)
    }
    if container.contains(.serviceProviderProvisioningState) {
        self.serviceProviderProvisioningState = try container.decode(ServiceProviderProvisioningStateEnum?.self, forKey: .serviceProviderProvisioningState)
    }
    if container.contains(.authorizations) {
        self.authorizations = try container.decode([ExpressRouteCircuitAuthorizationData?]?.self, forKey: .authorizations)
    }
    if container.contains(.peerings) {
        self.peerings = try container.decode([ExpressRouteCircuitPeeringData?]?.self, forKey: .peerings)
    }
    if container.contains(.serviceKey) {
        self.serviceKey = try container.decode(String?.self, forKey: .serviceKey)
    }
    if container.contains(.serviceProviderNotes) {
        self.serviceProviderNotes = try container.decode(String?.self, forKey: .serviceProviderNotes)
    }
    if container.contains(.serviceProviderProperties) {
        self.serviceProviderProperties = try container.decode(ExpressRouteCircuitServiceProviderPropertiesData?.self, forKey: .serviceProviderProperties)
    }
    if container.contains(.provisioningState) {
        self.provisioningState = try container.decode(String?.self, forKey: .provisioningState)
    }
    if container.contains(.gatewayManagerEtag) {
        self.gatewayManagerEtag = try container.decode(String?.self, forKey: .gatewayManagerEtag)
    }
    if var pageDecoder = decoder as? PageDecoder  {
      if pageDecoder.isPagedData,
        let nextLinkName = pageDecoder.nextLinkName {
          pageDecoder.nextLink = try UnknownCodingKey.decodeStringForKey(decoder: decoder, keyForDecode: nextLinkName)
      }
    }
  }

  public func encode(to encoder: Encoder) throws {
    var container = encoder.container(keyedBy: CodingKeys.self)
    if self.allowClassicOperations != nil {try container.encode(self.allowClassicOperations, forKey: .allowClassicOperations)}
    if self.circuitProvisioningState != nil {try container.encode(self.circuitProvisioningState, forKey: .circuitProvisioningState)}
    if self.serviceProviderProvisioningState != nil {try container.encode(self.serviceProviderProvisioningState, forKey: .serviceProviderProvisioningState)}
    if self.authorizations != nil {try container.encode(self.authorizations as! [ExpressRouteCircuitAuthorizationData?]?, forKey: .authorizations)}
    if self.peerings != nil {try container.encode(self.peerings as! [ExpressRouteCircuitPeeringData?]?, forKey: .peerings)}
    if self.serviceKey != nil {try container.encode(self.serviceKey, forKey: .serviceKey)}
    if self.serviceProviderNotes != nil {try container.encode(self.serviceProviderNotes, forKey: .serviceProviderNotes)}
    if self.serviceProviderProperties != nil {try container.encode(self.serviceProviderProperties as! ExpressRouteCircuitServiceProviderPropertiesData?, forKey: .serviceProviderProperties)}
    if self.provisioningState != nil {try container.encode(self.provisioningState, forKey: .provisioningState)}
    if self.gatewayManagerEtag != nil {try container.encode(self.gatewayManagerEtag, forKey: .gatewayManagerEtag)}
  }
}

extension DataFactory {
  public static func createExpressRouteCircuitPropertiesFormatProtocol() -> ExpressRouteCircuitPropertiesFormatProtocol {
    return ExpressRouteCircuitPropertiesFormatData()
  }
}
