// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
import Foundation
import azureSwiftRuntime
internal struct PoolUsageMetricsData : PoolUsageMetricsProtocol {
    public var poolId: String
    public var startTime: Date
    public var endTime: Date
    public var vmSize: String
    public var totalCoreHours: Double
    public var dataIngressGiB: Double
    public var dataEgressGiB: Double

        enum CodingKeys: String, CodingKey {case poolId = "poolId"
        case startTime = "startTime"
        case endTime = "endTime"
        case vmSize = "vmSize"
        case totalCoreHours = "totalCoreHours"
        case dataIngressGiB = "dataIngressGiB"
        case dataEgressGiB = "dataEgressGiB"
        }

  public init(poolId: String, startTime: Date, endTime: Date, vmSize: String, totalCoreHours: Double, dataIngressGiB: Double, dataEgressGiB: Double)  {
    self.poolId = poolId
    self.startTime = startTime
    self.endTime = endTime
    self.vmSize = vmSize
    self.totalCoreHours = totalCoreHours
    self.dataIngressGiB = dataIngressGiB
    self.dataEgressGiB = dataEgressGiB
  }

  public init(from decoder: Decoder) throws {
    let container = try decoder.container(keyedBy: CodingKeys.self)
      self.poolId = try container.decode(String.self, forKey: .poolId)
        self.startTime = DateConverter.fromString(dateStr: (try container.decode(String?.self, forKey: .startTime)), format: .dateTime)!
        self.endTime = DateConverter.fromString(dateStr: (try container.decode(String?.self, forKey: .endTime)), format: .dateTime)!
    self.vmSize = try container.decode(String.self, forKey: .vmSize)
    self.totalCoreHours = try container.decode(Double.self, forKey: .totalCoreHours)
    self.dataIngressGiB = try container.decode(Double.self, forKey: .dataIngressGiB)
    self.dataEgressGiB = try container.decode(Double.self, forKey: .dataEgressGiB)
    if var pageDecoder = decoder as? PageDecoder  {
      if pageDecoder.isPagedData,
        let nextLinkName = pageDecoder.nextLinkName {
          pageDecoder.nextLink = try UnknownCodingKey.decodeStringForKey(decoder: decoder, keyForDecode: nextLinkName)
      }
    }
  }

  public func encode(to encoder: Encoder) throws {
    var container = encoder.container(keyedBy: CodingKeys.self)
    try container.encode(self.poolId, forKey: .poolId)
    try container.encode(DateConverter.toString(date: self.startTime, format: .dateTime), forKey: .startTime)
    try container.encode(DateConverter.toString(date: self.endTime, format: .dateTime), forKey: .endTime)
    try container.encode(self.vmSize, forKey: .vmSize)
    try container.encode(self.totalCoreHours, forKey: .totalCoreHours)
    try container.encode(self.dataIngressGiB, forKey: .dataIngressGiB)
    try container.encode(self.dataEgressGiB, forKey: .dataEgressGiB)
  }
}

extension DataFactory {
  public static func createPoolUsageMetricsProtocol(poolId: String, startTime: Date, endTime: Date, vmSize: String, totalCoreHours: Double, dataIngressGiB: Double, dataEgressGiB: Double) -> PoolUsageMetricsProtocol {
    return PoolUsageMetricsData(poolId: poolId, startTime: startTime, endTime: endTime, vmSize: vmSize, totalCoreHours: totalCoreHours, dataIngressGiB: dataIngressGiB, dataEgressGiB: dataEgressGiB)
  }
}
