// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
import Foundation
import azureSwiftRuntime
internal struct ExitConditionsData : ExitConditionsProtocol {
    public var exitCodes: [ExitCodeMappingProtocol?]?
    public var exitCodeRanges: [ExitCodeRangeMappingProtocol?]?
    public var preProcessingError: ExitOptionsProtocol?
    public var fileUploadError: ExitOptionsProtocol?
    public var _default: ExitOptionsProtocol?

        enum CodingKeys: String, CodingKey {case exitCodes = "exitCodes"
        case exitCodeRanges = "exitCodeRanges"
        case preProcessingError = "preProcessingError"
        case fileUploadError = "fileUploadError"
        case _default = "default"
        }

  public init()  {
  }

  public init(from decoder: Decoder) throws {
    let container = try decoder.container(keyedBy: CodingKeys.self)
      if container.contains(.exitCodes) {
        self.exitCodes = try container.decode([ExitCodeMappingData?]?.self, forKey: .exitCodes)
    }
    if container.contains(.exitCodeRanges) {
        self.exitCodeRanges = try container.decode([ExitCodeRangeMappingData?]?.self, forKey: .exitCodeRanges)
    }
    if container.contains(.preProcessingError) {
        self.preProcessingError = try container.decode(ExitOptionsData?.self, forKey: .preProcessingError)
    }
    if container.contains(.fileUploadError) {
        self.fileUploadError = try container.decode(ExitOptionsData?.self, forKey: .fileUploadError)
    }
    if container.contains(._default) {
        self._default = try container.decode(ExitOptionsData?.self, forKey: ._default)
    }
    if var pageDecoder = decoder as? PageDecoder  {
      if pageDecoder.isPagedData,
        let nextLinkName = pageDecoder.nextLinkName {
          pageDecoder.nextLink = try UnknownCodingKey.decodeStringForKey(decoder: decoder, keyForDecode: nextLinkName)
      }
    }
  }

  public func encode(to encoder: Encoder) throws {
    var container = encoder.container(keyedBy: CodingKeys.self)
    if self.exitCodes != nil {try container.encode(self.exitCodes as! [ExitCodeMappingData?]?, forKey: .exitCodes)}
    if self.exitCodeRanges != nil {try container.encode(self.exitCodeRanges as! [ExitCodeRangeMappingData?]?, forKey: .exitCodeRanges)}
    if self.preProcessingError != nil {try container.encode(self.preProcessingError as! ExitOptionsData?, forKey: .preProcessingError)}
    if self.fileUploadError != nil {try container.encode(self.fileUploadError as! ExitOptionsData?, forKey: .fileUploadError)}
    if self._default != nil {try container.encode(self._default as! ExitOptionsData?, forKey: ._default)}
  }
}

extension DataFactory {
  public static func createExitConditionsProtocol() -> ExitConditionsProtocol {
    return ExitConditionsData()
  }
}
