// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
import Foundation
import azureSwiftRuntime
internal struct CorrelationFilterData : CorrelationFilterProtocol {
    public var correlationId: String?
    public var messageId: String?
    public var to: String?
    public var replyTo: String?
    public var label: String?
    public var sessionId: String?
    public var replyToSessionId: String?
    public var contentType: String?
    public var requiresPreprocessing: Bool?

        enum CodingKeys: String, CodingKey {case correlationId = "correlationId"
        case messageId = "messageId"
        case to = "to"
        case replyTo = "replyTo"
        case label = "label"
        case sessionId = "sessionId"
        case replyToSessionId = "replyToSessionId"
        case contentType = "contentType"
        case requiresPreprocessing = "requiresPreprocessing"
        }

  public init()  {
  }

  public init(from decoder: Decoder) throws {
    let container = try decoder.container(keyedBy: CodingKeys.self)
      if container.contains(.correlationId) {
        self.correlationId = try container.decode(String?.self, forKey: .correlationId)
    }
    if container.contains(.messageId) {
        self.messageId = try container.decode(String?.self, forKey: .messageId)
    }
    if container.contains(.to) {
        self.to = try container.decode(String?.self, forKey: .to)
    }
    if container.contains(.replyTo) {
        self.replyTo = try container.decode(String?.self, forKey: .replyTo)
    }
    if container.contains(.label) {
        self.label = try container.decode(String?.self, forKey: .label)
    }
    if container.contains(.sessionId) {
        self.sessionId = try container.decode(String?.self, forKey: .sessionId)
    }
    if container.contains(.replyToSessionId) {
        self.replyToSessionId = try container.decode(String?.self, forKey: .replyToSessionId)
    }
    if container.contains(.contentType) {
        self.contentType = try container.decode(String?.self, forKey: .contentType)
    }
    if container.contains(.requiresPreprocessing) {
        self.requiresPreprocessing = try container.decode(Bool?.self, forKey: .requiresPreprocessing)
    }
    if var pageDecoder = decoder as? PageDecoder  {
      if pageDecoder.isPagedData,
        let nextLinkName = pageDecoder.nextLinkName {
          pageDecoder.nextLink = try UnknownCodingKey.decodeStringForKey(decoder: decoder, keyForDecode: nextLinkName)
      }
    }
  }

  public func encode(to encoder: Encoder) throws {
    var container = encoder.container(keyedBy: CodingKeys.self)
    if self.correlationId != nil {try container.encode(self.correlationId, forKey: .correlationId)}
    if self.messageId != nil {try container.encode(self.messageId, forKey: .messageId)}
    if self.to != nil {try container.encode(self.to, forKey: .to)}
    if self.replyTo != nil {try container.encode(self.replyTo, forKey: .replyTo)}
    if self.label != nil {try container.encode(self.label, forKey: .label)}
    if self.sessionId != nil {try container.encode(self.sessionId, forKey: .sessionId)}
    if self.replyToSessionId != nil {try container.encode(self.replyToSessionId, forKey: .replyToSessionId)}
    if self.contentType != nil {try container.encode(self.contentType, forKey: .contentType)}
    if self.requiresPreprocessing != nil {try container.encode(self.requiresPreprocessing, forKey: .requiresPreprocessing)}
  }
}

extension DataFactory {
  public static func createCorrelationFilterProtocol() -> CorrelationFilterProtocol {
    return CorrelationFilterData()
  }
}
