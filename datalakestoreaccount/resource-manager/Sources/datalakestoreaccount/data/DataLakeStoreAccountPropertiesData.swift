// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
import Foundation
import azureSwiftRuntime
internal struct DataLakeStoreAccountPropertiesData : DataLakeStoreAccountPropertiesProtocol, DataLakeStoreAccountPropertiesBasicProtocol {
    public var accountId: String?
    public var provisioningState: DataLakeStoreAccountStatusEnum?
    public var state: DataLakeStoreAccountStateEnum?
    public var creationTime: Date?
    public var lastModifiedTime: Date?
    public var endpoint: String?
    public var defaultGroup: String?
    public var encryptionConfig: EncryptionConfigProtocol?
    public var encryptionState: EncryptionStateEnum?
    public var encryptionProvisioningState: EncryptionProvisioningStateEnum?
    public var firewallRules: [FirewallRuleProtocol?]?
    public var firewallState: FirewallStateEnum?
    public var firewallAllowAzureIps: FirewallAllowAzureIpsStateEnum?
    public var trustedIdProviders: [TrustedIdProviderProtocol?]?
    public var trustedIdProviderState: TrustedIdProviderStateEnum?
    public var newTier: TierTypeEnum?
    public var currentTier: TierTypeEnum?

        enum CodingKeys: String, CodingKey {case accountId = "accountId"
        case provisioningState = "provisioningState"
        case state = "state"
        case creationTime = "creationTime"
        case lastModifiedTime = "lastModifiedTime"
        case endpoint = "endpoint"
        case defaultGroup = "defaultGroup"
        case encryptionConfig = "encryptionConfig"
        case encryptionState = "encryptionState"
        case encryptionProvisioningState = "encryptionProvisioningState"
        case firewallRules = "firewallRules"
        case firewallState = "firewallState"
        case firewallAllowAzureIps = "firewallAllowAzureIps"
        case trustedIdProviders = "trustedIdProviders"
        case trustedIdProviderState = "trustedIdProviderState"
        case newTier = "newTier"
        case currentTier = "currentTier"
        }

  public init()  {
  }

  public init(from decoder: Decoder) throws {
    let container = try decoder.container(keyedBy: CodingKeys.self)
      if container.contains(.accountId) {
        self.accountId = try container.decode(String?.self, forKey: .accountId)
    }
    if container.contains(.provisioningState) {
        self.provisioningState = try container.decode(DataLakeStoreAccountStatusEnum?.self, forKey: .provisioningState)
    }
    if container.contains(.state) {
        self.state = try container.decode(DataLakeStoreAccountStateEnum?.self, forKey: .state)
    }
    if container.contains(.creationTime) {
        self.creationTime = DateConverter.fromString(dateStr: (try container.decode(String?.self, forKey: .creationTime)), format: .dateTime)
    }
    if container.contains(.lastModifiedTime) {
        self.lastModifiedTime = DateConverter.fromString(dateStr: (try container.decode(String?.self, forKey: .lastModifiedTime)), format: .dateTime)
    }
    if container.contains(.endpoint) {
        self.endpoint = try container.decode(String?.self, forKey: .endpoint)
    }
    if container.contains(.defaultGroup) {
        self.defaultGroup = try container.decode(String?.self, forKey: .defaultGroup)
    }
    if container.contains(.encryptionConfig) {
        self.encryptionConfig = try container.decode(EncryptionConfigData?.self, forKey: .encryptionConfig)
    }
    if container.contains(.encryptionState) {
        self.encryptionState = try container.decode(EncryptionStateEnum?.self, forKey: .encryptionState)
    }
    if container.contains(.encryptionProvisioningState) {
        self.encryptionProvisioningState = try container.decode(EncryptionProvisioningStateEnum?.self, forKey: .encryptionProvisioningState)
    }
    if container.contains(.firewallRules) {
        self.firewallRules = try container.decode([FirewallRuleData?]?.self, forKey: .firewallRules)
    }
    if container.contains(.firewallState) {
        self.firewallState = try container.decode(FirewallStateEnum?.self, forKey: .firewallState)
    }
    if container.contains(.firewallAllowAzureIps) {
        self.firewallAllowAzureIps = try container.decode(FirewallAllowAzureIpsStateEnum?.self, forKey: .firewallAllowAzureIps)
    }
    if container.contains(.trustedIdProviders) {
        self.trustedIdProviders = try container.decode([TrustedIdProviderData?]?.self, forKey: .trustedIdProviders)
    }
    if container.contains(.trustedIdProviderState) {
        self.trustedIdProviderState = try container.decode(TrustedIdProviderStateEnum?.self, forKey: .trustedIdProviderState)
    }
    if container.contains(.newTier) {
        self.newTier = try container.decode(TierTypeEnum?.self, forKey: .newTier)
    }
    if container.contains(.currentTier) {
        self.currentTier = try container.decode(TierTypeEnum?.self, forKey: .currentTier)
    }
    if var pageDecoder = decoder as? PageDecoder  {
      if pageDecoder.isPagedData,
        let nextLinkName = pageDecoder.nextLinkName {
          pageDecoder.nextLink = try UnknownCodingKey.decodeStringForKey(decoder: decoder, keyForDecode: nextLinkName)
      }
    }
  }

  public func encode(to encoder: Encoder) throws {
    var container = encoder.container(keyedBy: CodingKeys.self)
    if self.accountId != nil {try container.encode(self.accountId, forKey: .accountId)}
    if self.provisioningState != nil {try container.encode(self.provisioningState, forKey: .provisioningState)}
    if self.state != nil {try container.encode(self.state, forKey: .state)}
    if self.creationTime != nil {
        try container.encode(DateConverter.toString(date: self.creationTime!, format: .dateTime), forKey: .creationTime)
    }
    if self.lastModifiedTime != nil {
        try container.encode(DateConverter.toString(date: self.lastModifiedTime!, format: .dateTime), forKey: .lastModifiedTime)
    }
    if self.endpoint != nil {try container.encode(self.endpoint, forKey: .endpoint)}
    if self.defaultGroup != nil {try container.encode(self.defaultGroup, forKey: .defaultGroup)}
    if self.encryptionConfig != nil {try container.encode(self.encryptionConfig as! EncryptionConfigData?, forKey: .encryptionConfig)}
    if self.encryptionState != nil {try container.encode(self.encryptionState, forKey: .encryptionState)}
    if self.encryptionProvisioningState != nil {try container.encode(self.encryptionProvisioningState, forKey: .encryptionProvisioningState)}
    if self.firewallRules != nil {try container.encode(self.firewallRules as! [FirewallRuleData?]?, forKey: .firewallRules)}
    if self.firewallState != nil {try container.encode(self.firewallState, forKey: .firewallState)}
    if self.firewallAllowAzureIps != nil {try container.encode(self.firewallAllowAzureIps, forKey: .firewallAllowAzureIps)}
    if self.trustedIdProviders != nil {try container.encode(self.trustedIdProviders as! [TrustedIdProviderData?]?, forKey: .trustedIdProviders)}
    if self.trustedIdProviderState != nil {try container.encode(self.trustedIdProviderState, forKey: .trustedIdProviderState)}
    if self.newTier != nil {try container.encode(self.newTier, forKey: .newTier)}
    if self.currentTier != nil {try container.encode(self.currentTier, forKey: .currentTier)}
  }
}

extension DataFactory {
  public static func createDataLakeStoreAccountPropertiesProtocol() -> DataLakeStoreAccountPropertiesProtocol {
    return DataLakeStoreAccountPropertiesData()
  }
}
