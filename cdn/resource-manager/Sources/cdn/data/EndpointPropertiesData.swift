// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
import Foundation
import azureSwiftRuntime
internal struct EndpointPropertiesData : EndpointPropertiesProtocol, EndpointPropertiesUpdateParametersProtocol {
    public var originHostHeader: String?
    public var originPath: String?
    public var contentTypesToCompress: [String]?
    public var isCompressionEnabled: Bool?
    public var isHttpAllowed: Bool?
    public var isHttpsAllowed: Bool?
    public var queryStringCachingBehavior: QueryStringCachingBehaviorEnum?
    public var optimizationType: OptimizationTypeEnum?
    public var probePath: String?
    public var geoFilters: [GeoFilterProtocol?]?
    public var hostName: String?
    public var origins: [DeepCreatedOriginProtocol]
    public var resourceState: EndpointResourceStateEnum?
    public var provisioningState: String?

        enum CodingKeys: String, CodingKey {case originHostHeader = "originHostHeader"
        case originPath = "originPath"
        case contentTypesToCompress = "contentTypesToCompress"
        case isCompressionEnabled = "isCompressionEnabled"
        case isHttpAllowed = "isHttpAllowed"
        case isHttpsAllowed = "isHttpsAllowed"
        case queryStringCachingBehavior = "queryStringCachingBehavior"
        case optimizationType = "optimizationType"
        case probePath = "probePath"
        case geoFilters = "geoFilters"
        case hostName = "hostName"
        case origins = "origins"
        case resourceState = "resourceState"
        case provisioningState = "provisioningState"
        }

  public init(origins: [DeepCreatedOriginProtocol])  {
    self.origins = origins
  }

  public init(from decoder: Decoder) throws {
    let container = try decoder.container(keyedBy: CodingKeys.self)
      if container.contains(.originHostHeader) {
        self.originHostHeader = try container.decode(String?.self, forKey: .originHostHeader)
    }
    if container.contains(.originPath) {
        self.originPath = try container.decode(String?.self, forKey: .originPath)
    }
    if container.contains(.contentTypesToCompress) {
        self.contentTypesToCompress = try container.decode([String]?.self, forKey: .contentTypesToCompress)
    }
    if container.contains(.isCompressionEnabled) {
        self.isCompressionEnabled = try container.decode(Bool?.self, forKey: .isCompressionEnabled)
    }
    if container.contains(.isHttpAllowed) {
        self.isHttpAllowed = try container.decode(Bool?.self, forKey: .isHttpAllowed)
    }
    if container.contains(.isHttpsAllowed) {
        self.isHttpsAllowed = try container.decode(Bool?.self, forKey: .isHttpsAllowed)
    }
    if container.contains(.queryStringCachingBehavior) {
        self.queryStringCachingBehavior = try container.decode(QueryStringCachingBehaviorEnum?.self, forKey: .queryStringCachingBehavior)
    }
    if container.contains(.optimizationType) {
        self.optimizationType = try container.decode(OptimizationTypeEnum?.self, forKey: .optimizationType)
    }
    if container.contains(.probePath) {
        self.probePath = try container.decode(String?.self, forKey: .probePath)
    }
    if container.contains(.geoFilters) {
        self.geoFilters = try container.decode([GeoFilterData?]?.self, forKey: .geoFilters)
    }
    if container.contains(.hostName) {
        self.hostName = try container.decode(String?.self, forKey: .hostName)
    }
    self.origins = try container.decode([DeepCreatedOriginData].self, forKey: .origins)
    if container.contains(.resourceState) {
        self.resourceState = try container.decode(EndpointResourceStateEnum?.self, forKey: .resourceState)
    }
    if container.contains(.provisioningState) {
        self.provisioningState = try container.decode(String?.self, forKey: .provisioningState)
    }
    if var pageDecoder = decoder as? PageDecoder  {
      if pageDecoder.isPagedData,
        let nextLinkName = pageDecoder.nextLinkName {
          pageDecoder.nextLink = try UnknownCodingKey.decodeStringForKey(decoder: decoder, keyForDecode: nextLinkName)
      }
    }
  }

  public func encode(to encoder: Encoder) throws {
    var container = encoder.container(keyedBy: CodingKeys.self)
    if self.originHostHeader != nil {try container.encode(self.originHostHeader, forKey: .originHostHeader)}
    if self.originPath != nil {try container.encode(self.originPath, forKey: .originPath)}
    if self.contentTypesToCompress != nil {try container.encode(self.contentTypesToCompress as! [String]?, forKey: .contentTypesToCompress)}
    if self.isCompressionEnabled != nil {try container.encode(self.isCompressionEnabled, forKey: .isCompressionEnabled)}
    if self.isHttpAllowed != nil {try container.encode(self.isHttpAllowed, forKey: .isHttpAllowed)}
    if self.isHttpsAllowed != nil {try container.encode(self.isHttpsAllowed, forKey: .isHttpsAllowed)}
    if self.queryStringCachingBehavior != nil {try container.encode(self.queryStringCachingBehavior, forKey: .queryStringCachingBehavior)}
    if self.optimizationType != nil {try container.encode(self.optimizationType, forKey: .optimizationType)}
    if self.probePath != nil {try container.encode(self.probePath, forKey: .probePath)}
    if self.geoFilters != nil {try container.encode(self.geoFilters as! [GeoFilterData?]?, forKey: .geoFilters)}
    if self.hostName != nil {try container.encode(self.hostName, forKey: .hostName)}
    try container.encode(self.origins as! [DeepCreatedOriginData], forKey: .origins)
    if self.resourceState != nil {try container.encode(self.resourceState, forKey: .resourceState)}
    if self.provisioningState != nil {try container.encode(self.provisioningState, forKey: .provisioningState)}
  }
}

extension DataFactory {
  public static func createEndpointPropertiesProtocol(origins: [DeepCreatedOriginProtocol]) -> EndpointPropertiesProtocol {
    return EndpointPropertiesData(origins: origins)
  }
}
