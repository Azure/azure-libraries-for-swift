// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
import Foundation
import azureSwiftRuntime
internal struct InMageAzureV2ReplicationDetailsData : InMageAzureV2ReplicationDetailsProtocol, ReplicationProviderSpecificSettingsProtocol {
    public var infrastructureVmId: String?
    public var vCenterInfrastructureId: String?
    public var protectionStage: String?
    public var vmId: String?
    public var vmProtectionState: String?
    public var vmProtectionStateDescription: String?
    public var resyncProgressPercentage: Int32?
    public var rpoInSeconds: Int64?
    public var compressedDataRateInMB: Double?
    public var uncompressedDataRateInMB: Double?
    public var ipAddress: String?
    public var agentVersion: String?
    public var agentExpiryDate: Date?
    public var isAgentUpdateRequired: String?
    public var isRebootAfterUpdateRequired: String?
    public var lastHeartbeat: Date?
    public var processServerId: String?
    public var multiVmGroupId: String?
    public var multiVmGroupName: String?
    public var multiVmSyncStatus: String?
    public var protectedDisks: [InMageAzureV2ProtectedDiskDetailsProtocol?]?
    public var diskResized: String?
    public var masterTargetId: String?
    public var sourceVmCpuCount: Int32?
    public var sourceVmRamSizeInMB: Int32?
    public var osType: String?
    public var vhdName: String?
    public var osDiskId: String?
    public var azureVMDiskDetails: [AzureVmDiskDetailsProtocol?]?
    public var recoveryAzureVMName: String?
    public var recoveryAzureVMSize: String?
    public var recoveryAzureStorageAccount: String?
    public var recoveryAzureLogStorageAccountId: String?
    public var vmNics: [VMNicDetailsProtocol?]?
    public var selectedRecoveryAzureNetworkId: String?
    public var selectedSourceNicId: String?
    public var discoveryType: String?
    public var enableRdpOnTargetOption: String?
    public var datastores: [String]?
    public var targetVmId: String?
    public var recoveryAzureResourceGroupId: String?
    public var recoveryAvailabilitySetId: String?
    public var useManagedDisks: String?
    public var licenseType: String?
    public var validationErrors: [HealthErrorProtocol?]?
    public var lastRpoCalculatedTime: Date?
    public var lastUpdateReceivedTime: Date?
    public var replicaId: String?
    public var osVersion: String?

        enum CodingKeys: String, CodingKey {case infrastructureVmId = "infrastructureVmId"
        case vCenterInfrastructureId = "vCenterInfrastructureId"
        case protectionStage = "protectionStage"
        case vmId = "vmId"
        case vmProtectionState = "vmProtectionState"
        case vmProtectionStateDescription = "vmProtectionStateDescription"
        case resyncProgressPercentage = "resyncProgressPercentage"
        case rpoInSeconds = "rpoInSeconds"
        case compressedDataRateInMB = "compressedDataRateInMB"
        case uncompressedDataRateInMB = "uncompressedDataRateInMB"
        case ipAddress = "ipAddress"
        case agentVersion = "agentVersion"
        case agentExpiryDate = "agentExpiryDate"
        case isAgentUpdateRequired = "isAgentUpdateRequired"
        case isRebootAfterUpdateRequired = "isRebootAfterUpdateRequired"
        case lastHeartbeat = "lastHeartbeat"
        case processServerId = "processServerId"
        case multiVmGroupId = "multiVmGroupId"
        case multiVmGroupName = "multiVmGroupName"
        case multiVmSyncStatus = "multiVmSyncStatus"
        case protectedDisks = "protectedDisks"
        case diskResized = "diskResized"
        case masterTargetId = "masterTargetId"
        case sourceVmCpuCount = "sourceVmCpuCount"
        case sourceVmRamSizeInMB = "sourceVmRamSizeInMB"
        case osType = "osType"
        case vhdName = "vhdName"
        case osDiskId = "osDiskId"
        case azureVMDiskDetails = "azureVMDiskDetails"
        case recoveryAzureVMName = "recoveryAzureVMName"
        case recoveryAzureVMSize = "recoveryAzureVMSize"
        case recoveryAzureStorageAccount = "recoveryAzureStorageAccount"
        case recoveryAzureLogStorageAccountId = "recoveryAzureLogStorageAccountId"
        case vmNics = "vmNics"
        case selectedRecoveryAzureNetworkId = "selectedRecoveryAzureNetworkId"
        case selectedSourceNicId = "selectedSourceNicId"
        case discoveryType = "discoveryType"
        case enableRdpOnTargetOption = "enableRdpOnTargetOption"
        case datastores = "datastores"
        case targetVmId = "targetVmId"
        case recoveryAzureResourceGroupId = "recoveryAzureResourceGroupId"
        case recoveryAvailabilitySetId = "recoveryAvailabilitySetId"
        case useManagedDisks = "useManagedDisks"
        case licenseType = "licenseType"
        case validationErrors = "validationErrors"
        case lastRpoCalculatedTime = "lastRpoCalculatedTime"
        case lastUpdateReceivedTime = "lastUpdateReceivedTime"
        case replicaId = "replicaId"
        case osVersion = "osVersion"
        }

  public init()  {
  }

  public init(from decoder: Decoder) throws {
    let container = try decoder.container(keyedBy: CodingKeys.self)
      if container.contains(.infrastructureVmId) {
        self.infrastructureVmId = try container.decode(String?.self, forKey: .infrastructureVmId)
    }
    if container.contains(.vCenterInfrastructureId) {
        self.vCenterInfrastructureId = try container.decode(String?.self, forKey: .vCenterInfrastructureId)
    }
    if container.contains(.protectionStage) {
        self.protectionStage = try container.decode(String?.self, forKey: .protectionStage)
    }
    if container.contains(.vmId) {
        self.vmId = try container.decode(String?.self, forKey: .vmId)
    }
    if container.contains(.vmProtectionState) {
        self.vmProtectionState = try container.decode(String?.self, forKey: .vmProtectionState)
    }
    if container.contains(.vmProtectionStateDescription) {
        self.vmProtectionStateDescription = try container.decode(String?.self, forKey: .vmProtectionStateDescription)
    }
    if container.contains(.resyncProgressPercentage) {
        self.resyncProgressPercentage = try container.decode(Int32?.self, forKey: .resyncProgressPercentage)
    }
    if container.contains(.rpoInSeconds) {
        self.rpoInSeconds = try container.decode(Int64?.self, forKey: .rpoInSeconds)
    }
    if container.contains(.compressedDataRateInMB) {
        self.compressedDataRateInMB = try container.decode(Double?.self, forKey: .compressedDataRateInMB)
    }
    if container.contains(.uncompressedDataRateInMB) {
        self.uncompressedDataRateInMB = try container.decode(Double?.self, forKey: .uncompressedDataRateInMB)
    }
    if container.contains(.ipAddress) {
        self.ipAddress = try container.decode(String?.self, forKey: .ipAddress)
    }
    if container.contains(.agentVersion) {
        self.agentVersion = try container.decode(String?.self, forKey: .agentVersion)
    }
    if container.contains(.agentExpiryDate) {
        self.agentExpiryDate = DateConverter.fromString(dateStr: (try container.decode(String?.self, forKey: .agentExpiryDate)), format: .dateTime)
    }
    if container.contains(.isAgentUpdateRequired) {
        self.isAgentUpdateRequired = try container.decode(String?.self, forKey: .isAgentUpdateRequired)
    }
    if container.contains(.isRebootAfterUpdateRequired) {
        self.isRebootAfterUpdateRequired = try container.decode(String?.self, forKey: .isRebootAfterUpdateRequired)
    }
    if container.contains(.lastHeartbeat) {
        self.lastHeartbeat = DateConverter.fromString(dateStr: (try container.decode(String?.self, forKey: .lastHeartbeat)), format: .dateTime)
    }
    if container.contains(.processServerId) {
        self.processServerId = try container.decode(String?.self, forKey: .processServerId)
    }
    if container.contains(.multiVmGroupId) {
        self.multiVmGroupId = try container.decode(String?.self, forKey: .multiVmGroupId)
    }
    if container.contains(.multiVmGroupName) {
        self.multiVmGroupName = try container.decode(String?.self, forKey: .multiVmGroupName)
    }
    if container.contains(.multiVmSyncStatus) {
        self.multiVmSyncStatus = try container.decode(String?.self, forKey: .multiVmSyncStatus)
    }
    if container.contains(.protectedDisks) {
        self.protectedDisks = try container.decode([InMageAzureV2ProtectedDiskDetailsData?]?.self, forKey: .protectedDisks)
    }
    if container.contains(.diskResized) {
        self.diskResized = try container.decode(String?.self, forKey: .diskResized)
    }
    if container.contains(.masterTargetId) {
        self.masterTargetId = try container.decode(String?.self, forKey: .masterTargetId)
    }
    if container.contains(.sourceVmCpuCount) {
        self.sourceVmCpuCount = try container.decode(Int32?.self, forKey: .sourceVmCpuCount)
    }
    if container.contains(.sourceVmRamSizeInMB) {
        self.sourceVmRamSizeInMB = try container.decode(Int32?.self, forKey: .sourceVmRamSizeInMB)
    }
    if container.contains(.osType) {
        self.osType = try container.decode(String?.self, forKey: .osType)
    }
    if container.contains(.vhdName) {
        self.vhdName = try container.decode(String?.self, forKey: .vhdName)
    }
    if container.contains(.osDiskId) {
        self.osDiskId = try container.decode(String?.self, forKey: .osDiskId)
    }
    if container.contains(.azureVMDiskDetails) {
        self.azureVMDiskDetails = try container.decode([AzureVmDiskDetailsData?]?.self, forKey: .azureVMDiskDetails)
    }
    if container.contains(.recoveryAzureVMName) {
        self.recoveryAzureVMName = try container.decode(String?.self, forKey: .recoveryAzureVMName)
    }
    if container.contains(.recoveryAzureVMSize) {
        self.recoveryAzureVMSize = try container.decode(String?.self, forKey: .recoveryAzureVMSize)
    }
    if container.contains(.recoveryAzureStorageAccount) {
        self.recoveryAzureStorageAccount = try container.decode(String?.self, forKey: .recoveryAzureStorageAccount)
    }
    if container.contains(.recoveryAzureLogStorageAccountId) {
        self.recoveryAzureLogStorageAccountId = try container.decode(String?.self, forKey: .recoveryAzureLogStorageAccountId)
    }
    if container.contains(.vmNics) {
        self.vmNics = try container.decode([VMNicDetailsData?]?.self, forKey: .vmNics)
    }
    if container.contains(.selectedRecoveryAzureNetworkId) {
        self.selectedRecoveryAzureNetworkId = try container.decode(String?.self, forKey: .selectedRecoveryAzureNetworkId)
    }
    if container.contains(.selectedSourceNicId) {
        self.selectedSourceNicId = try container.decode(String?.self, forKey: .selectedSourceNicId)
    }
    if container.contains(.discoveryType) {
        self.discoveryType = try container.decode(String?.self, forKey: .discoveryType)
    }
    if container.contains(.enableRdpOnTargetOption) {
        self.enableRdpOnTargetOption = try container.decode(String?.self, forKey: .enableRdpOnTargetOption)
    }
    if container.contains(.datastores) {
        self.datastores = try container.decode([String]?.self, forKey: .datastores)
    }
    if container.contains(.targetVmId) {
        self.targetVmId = try container.decode(String?.self, forKey: .targetVmId)
    }
    if container.contains(.recoveryAzureResourceGroupId) {
        self.recoveryAzureResourceGroupId = try container.decode(String?.self, forKey: .recoveryAzureResourceGroupId)
    }
    if container.contains(.recoveryAvailabilitySetId) {
        self.recoveryAvailabilitySetId = try container.decode(String?.self, forKey: .recoveryAvailabilitySetId)
    }
    if container.contains(.useManagedDisks) {
        self.useManagedDisks = try container.decode(String?.self, forKey: .useManagedDisks)
    }
    if container.contains(.licenseType) {
        self.licenseType = try container.decode(String?.self, forKey: .licenseType)
    }
    if container.contains(.validationErrors) {
        self.validationErrors = try container.decode([HealthErrorData?]?.self, forKey: .validationErrors)
    }
    if container.contains(.lastRpoCalculatedTime) {
        self.lastRpoCalculatedTime = DateConverter.fromString(dateStr: (try container.decode(String?.self, forKey: .lastRpoCalculatedTime)), format: .dateTime)
    }
    if container.contains(.lastUpdateReceivedTime) {
        self.lastUpdateReceivedTime = DateConverter.fromString(dateStr: (try container.decode(String?.self, forKey: .lastUpdateReceivedTime)), format: .dateTime)
    }
    if container.contains(.replicaId) {
        self.replicaId = try container.decode(String?.self, forKey: .replicaId)
    }
    if container.contains(.osVersion) {
        self.osVersion = try container.decode(String?.self, forKey: .osVersion)
    }
    if var pageDecoder = decoder as? PageDecoder  {
      if pageDecoder.isPagedData,
        let nextLinkName = pageDecoder.nextLinkName {
          pageDecoder.nextLink = try UnknownCodingKey.decodeStringForKey(decoder: decoder, keyForDecode: nextLinkName)
      }
    }
  }

  public func encode(to encoder: Encoder) throws {
    var container = encoder.container(keyedBy: CodingKeys.self)
    if self.infrastructureVmId != nil {try container.encode(self.infrastructureVmId, forKey: .infrastructureVmId)}
    if self.vCenterInfrastructureId != nil {try container.encode(self.vCenterInfrastructureId, forKey: .vCenterInfrastructureId)}
    if self.protectionStage != nil {try container.encode(self.protectionStage, forKey: .protectionStage)}
    if self.vmId != nil {try container.encode(self.vmId, forKey: .vmId)}
    if self.vmProtectionState != nil {try container.encode(self.vmProtectionState, forKey: .vmProtectionState)}
    if self.vmProtectionStateDescription != nil {try container.encode(self.vmProtectionStateDescription, forKey: .vmProtectionStateDescription)}
    if self.resyncProgressPercentage != nil {try container.encode(self.resyncProgressPercentage, forKey: .resyncProgressPercentage)}
    if self.rpoInSeconds != nil {try container.encode(self.rpoInSeconds, forKey: .rpoInSeconds)}
    if self.compressedDataRateInMB != nil {try container.encode(self.compressedDataRateInMB, forKey: .compressedDataRateInMB)}
    if self.uncompressedDataRateInMB != nil {try container.encode(self.uncompressedDataRateInMB, forKey: .uncompressedDataRateInMB)}
    if self.ipAddress != nil {try container.encode(self.ipAddress, forKey: .ipAddress)}
    if self.agentVersion != nil {try container.encode(self.agentVersion, forKey: .agentVersion)}
    if self.agentExpiryDate != nil {
        try container.encode(DateConverter.toString(date: self.agentExpiryDate!, format: .dateTime), forKey: .agentExpiryDate)
    }
    if self.isAgentUpdateRequired != nil {try container.encode(self.isAgentUpdateRequired, forKey: .isAgentUpdateRequired)}
    if self.isRebootAfterUpdateRequired != nil {try container.encode(self.isRebootAfterUpdateRequired, forKey: .isRebootAfterUpdateRequired)}
    if self.lastHeartbeat != nil {
        try container.encode(DateConverter.toString(date: self.lastHeartbeat!, format: .dateTime), forKey: .lastHeartbeat)
    }
    if self.processServerId != nil {try container.encode(self.processServerId, forKey: .processServerId)}
    if self.multiVmGroupId != nil {try container.encode(self.multiVmGroupId, forKey: .multiVmGroupId)}
    if self.multiVmGroupName != nil {try container.encode(self.multiVmGroupName, forKey: .multiVmGroupName)}
    if self.multiVmSyncStatus != nil {try container.encode(self.multiVmSyncStatus, forKey: .multiVmSyncStatus)}
    if self.protectedDisks != nil {try container.encode(self.protectedDisks as! [InMageAzureV2ProtectedDiskDetailsData?]?, forKey: .protectedDisks)}
    if self.diskResized != nil {try container.encode(self.diskResized, forKey: .diskResized)}
    if self.masterTargetId != nil {try container.encode(self.masterTargetId, forKey: .masterTargetId)}
    if self.sourceVmCpuCount != nil {try container.encode(self.sourceVmCpuCount, forKey: .sourceVmCpuCount)}
    if self.sourceVmRamSizeInMB != nil {try container.encode(self.sourceVmRamSizeInMB, forKey: .sourceVmRamSizeInMB)}
    if self.osType != nil {try container.encode(self.osType, forKey: .osType)}
    if self.vhdName != nil {try container.encode(self.vhdName, forKey: .vhdName)}
    if self.osDiskId != nil {try container.encode(self.osDiskId, forKey: .osDiskId)}
    if self.azureVMDiskDetails != nil {try container.encode(self.azureVMDiskDetails as! [AzureVmDiskDetailsData?]?, forKey: .azureVMDiskDetails)}
    if self.recoveryAzureVMName != nil {try container.encode(self.recoveryAzureVMName, forKey: .recoveryAzureVMName)}
    if self.recoveryAzureVMSize != nil {try container.encode(self.recoveryAzureVMSize, forKey: .recoveryAzureVMSize)}
    if self.recoveryAzureStorageAccount != nil {try container.encode(self.recoveryAzureStorageAccount, forKey: .recoveryAzureStorageAccount)}
    if self.recoveryAzureLogStorageAccountId != nil {try container.encode(self.recoveryAzureLogStorageAccountId, forKey: .recoveryAzureLogStorageAccountId)}
    if self.vmNics != nil {try container.encode(self.vmNics as! [VMNicDetailsData?]?, forKey: .vmNics)}
    if self.selectedRecoveryAzureNetworkId != nil {try container.encode(self.selectedRecoveryAzureNetworkId, forKey: .selectedRecoveryAzureNetworkId)}
    if self.selectedSourceNicId != nil {try container.encode(self.selectedSourceNicId, forKey: .selectedSourceNicId)}
    if self.discoveryType != nil {try container.encode(self.discoveryType, forKey: .discoveryType)}
    if self.enableRdpOnTargetOption != nil {try container.encode(self.enableRdpOnTargetOption, forKey: .enableRdpOnTargetOption)}
    if self.datastores != nil {try container.encode(self.datastores as! [String]?, forKey: .datastores)}
    if self.targetVmId != nil {try container.encode(self.targetVmId, forKey: .targetVmId)}
    if self.recoveryAzureResourceGroupId != nil {try container.encode(self.recoveryAzureResourceGroupId, forKey: .recoveryAzureResourceGroupId)}
    if self.recoveryAvailabilitySetId != nil {try container.encode(self.recoveryAvailabilitySetId, forKey: .recoveryAvailabilitySetId)}
    if self.useManagedDisks != nil {try container.encode(self.useManagedDisks, forKey: .useManagedDisks)}
    if self.licenseType != nil {try container.encode(self.licenseType, forKey: .licenseType)}
    if self.validationErrors != nil {try container.encode(self.validationErrors as! [HealthErrorData?]?, forKey: .validationErrors)}
    if self.lastRpoCalculatedTime != nil {
        try container.encode(DateConverter.toString(date: self.lastRpoCalculatedTime!, format: .dateTime), forKey: .lastRpoCalculatedTime)
    }
    if self.lastUpdateReceivedTime != nil {
        try container.encode(DateConverter.toString(date: self.lastUpdateReceivedTime!, format: .dateTime), forKey: .lastUpdateReceivedTime)
    }
    if self.replicaId != nil {try container.encode(self.replicaId, forKey: .replicaId)}
    if self.osVersion != nil {try container.encode(self.osVersion, forKey: .osVersion)}
  }
}

extension DataFactory {
  public static func createInMageAzureV2ReplicationDetailsProtocol() -> InMageAzureV2ReplicationDetailsProtocol {
    return InMageAzureV2ReplicationDetailsData()
  }
}
