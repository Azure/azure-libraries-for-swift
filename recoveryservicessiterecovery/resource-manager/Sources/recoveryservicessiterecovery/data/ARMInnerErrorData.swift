// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
import Foundation
import azureSwiftRuntime
internal struct ARMInnerErrorData : ARMInnerErrorProtocol {
    public var trace: String?
    public var source: String?
    public var methodStatus: MethodCallStatusProtocol?
    public var cloudId: String?
    public var hVHostId: String?
    public var hVClusterId: String?
    public var networkId: String?
    public var vmId: String?
    public var fabricId: String?
    public var liveId: String?
    public var containerId: String?
    public var resourceId: String?
    public var resourceName: String?
    public var subscriptionId: String?
    public var serializedSRSLogContext: String?

        enum CodingKeys: String, CodingKey {case trace = "trace"
        case source = "source"
        case methodStatus = "methodStatus"
        case cloudId = "cloudId"
        case hVHostId = "hVHostId"
        case hVClusterId = "hVClusterId"
        case networkId = "networkId"
        case vmId = "vmId"
        case fabricId = "fabricId"
        case liveId = "liveId"
        case containerId = "containerId"
        case resourceId = "resourceId"
        case resourceName = "resourceName"
        case subscriptionId = "subscriptionId"
        case serializedSRSLogContext = "serializedSRSLogContext"
        }

  public init()  {
  }

  public init(from decoder: Decoder) throws {
    let container = try decoder.container(keyedBy: CodingKeys.self)
      if container.contains(.trace) {
        self.trace = try container.decode(String?.self, forKey: .trace)
    }
    if container.contains(.source) {
        self.source = try container.decode(String?.self, forKey: .source)
    }
    if container.contains(.methodStatus) {
        self.methodStatus = try container.decode(MethodCallStatusData?.self, forKey: .methodStatus)
    }
    if container.contains(.cloudId) {
        self.cloudId = try container.decode(String?.self, forKey: .cloudId)
    }
    if container.contains(.hVHostId) {
        self.hVHostId = try container.decode(String?.self, forKey: .hVHostId)
    }
    if container.contains(.hVClusterId) {
        self.hVClusterId = try container.decode(String?.self, forKey: .hVClusterId)
    }
    if container.contains(.networkId) {
        self.networkId = try container.decode(String?.self, forKey: .networkId)
    }
    if container.contains(.vmId) {
        self.vmId = try container.decode(String?.self, forKey: .vmId)
    }
    if container.contains(.fabricId) {
        self.fabricId = try container.decode(String?.self, forKey: .fabricId)
    }
    if container.contains(.liveId) {
        self.liveId = try container.decode(String?.self, forKey: .liveId)
    }
    if container.contains(.containerId) {
        self.containerId = try container.decode(String?.self, forKey: .containerId)
    }
    if container.contains(.resourceId) {
        self.resourceId = try container.decode(String?.self, forKey: .resourceId)
    }
    if container.contains(.resourceName) {
        self.resourceName = try container.decode(String?.self, forKey: .resourceName)
    }
    if container.contains(.subscriptionId) {
        self.subscriptionId = try container.decode(String?.self, forKey: .subscriptionId)
    }
    if container.contains(.serializedSRSLogContext) {
        self.serializedSRSLogContext = try container.decode(String?.self, forKey: .serializedSRSLogContext)
    }
    if var pageDecoder = decoder as? PageDecoder  {
      if pageDecoder.isPagedData,
        let nextLinkName = pageDecoder.nextLinkName {
          pageDecoder.nextLink = try UnknownCodingKey.decodeStringForKey(decoder: decoder, keyForDecode: nextLinkName)
      }
    }
  }

  public func encode(to encoder: Encoder) throws {
    var container = encoder.container(keyedBy: CodingKeys.self)
    if self.trace != nil {try container.encode(self.trace, forKey: .trace)}
    if self.source != nil {try container.encode(self.source, forKey: .source)}
    if self.methodStatus != nil {try container.encode(self.methodStatus as! MethodCallStatusData?, forKey: .methodStatus)}
    if self.cloudId != nil {try container.encode(self.cloudId, forKey: .cloudId)}
    if self.hVHostId != nil {try container.encode(self.hVHostId, forKey: .hVHostId)}
    if self.hVClusterId != nil {try container.encode(self.hVClusterId, forKey: .hVClusterId)}
    if self.networkId != nil {try container.encode(self.networkId, forKey: .networkId)}
    if self.vmId != nil {try container.encode(self.vmId, forKey: .vmId)}
    if self.fabricId != nil {try container.encode(self.fabricId, forKey: .fabricId)}
    if self.liveId != nil {try container.encode(self.liveId, forKey: .liveId)}
    if self.containerId != nil {try container.encode(self.containerId, forKey: .containerId)}
    if self.resourceId != nil {try container.encode(self.resourceId, forKey: .resourceId)}
    if self.resourceName != nil {try container.encode(self.resourceName, forKey: .resourceName)}
    if self.subscriptionId != nil {try container.encode(self.subscriptionId, forKey: .subscriptionId)}
    if self.serializedSRSLogContext != nil {try container.encode(self.serializedSRSLogContext, forKey: .serializedSRSLogContext)}
  }
}

extension DataFactory {
  public static func createARMInnerErrorProtocol() -> ARMInnerErrorProtocol {
    return ARMInnerErrorData()
  }
}
